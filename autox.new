# vim: ft=sh
cd ${AX_BASE:-~};
if [[ -r $AX_BASE/cache/usecache ]]; then
    AX_CACHE_SITE=$AX_BASE/cache/usecache;
    SHAPRINT_THIS="$(eval shasum `find -type f -not -iname 'shasumprint' -not -type l -iname '*[^~]' -printf '"'$PWD'/%P"\n'` | shasum)";
    [[ -r $AX_BASE/shasumprint ]] && SHAPRINT_PREV="$(cat $AX_BASE/shasumprint)" || SHAPRINT_PREV=NONE;
    if [[ "$SHAPRINT_THIS" == "$SHAPRINT_PREV" ]]; then
        echo "No changes in any files, cache load will continue...";
        echo "Loading from Cache: use 'ax.updatecache' if you want to force an update of the cache";
        echo "(or delete $AX_BASE/shasumprint)";
        if for i in $AX_BASE/cache/usecache/*.cache;
        do
            source "$i";
        done; then
            echo "Cache load succeeded.";
        else
            echo "Cache load failed, please check to make sure your cache is backed up properly!";
        fi;
        read -sn1;
    else
        echo "Files have changed, doing a full load... please use ax.cache.create to make a new cache if you";
        echo "want to enable cache support again!";
    fi;
else
    if [[ -z ${AX_ONE_TIME_MESSAGES[NOCACHE]} ]]; then
        declare -gA AX_ONE_TIME_MESSAGES;
        AX_ONE_TIME_MESSAGES[NOCACHE]=1;
        echo "hint: no cache available, use ax.cache.create if you want faster load times!";
    fi;
fi;
if [[ ! -v AX_USER_VARS_INITIALIZED ]]; then
    declare -g AX_STARTUP_FILE_NAME="$BASH_SOURCE";
    declare -gi AX_USER_BASHRC_ORIGINATED=0;
    declare -gi AX_USER_BASHRC_ORIGIN_COUNT=0;
    declare -gr AX_USER_VARS_INITIALIZED=1;
fi;
for x in "${BASH_SOURCE[@]}";
do
    true debug printf "%s <- " "$x";
    if [[ $x == ~/.bashrc ]]; then
        AX_USER_BASHRC_ORIGINATED=1;
        let AX_USER_BASHRC_ORIGIN_COUNT++;
    fi;
done;
if [[ $AX_USER_BASHRC_ORIGINATED -eq 1 ]]; then
    true debug echo "Triggering AutoX Load OK (request comes from user's home)";
else
    true debug echo "Triggering AutoX Load DENY (request comes from outside user's home)";
    return 0;
fi;
[[ $(tty) != "" ]] && function ax.usage () 
{ 
    R=$?;
    cat $BASH_SOURCE | grep --color=auto -Po '(?<=USAGE:\s).*$';
    return $R
} || function ax.usage () 
{ 
    :
};
[[ -w ~/tmp/autox-dbg-logme ]] && echo "$@ from $(declare -p BASH_SOURCE)" >> /tmp/autox-startups;
[[ ! $- =~ i ]] && { 
    echo;
    echo "please use \". $BASH_SOURCE\" to run this script!!";
    ax.usage;
    sleep 2;
    exit 1
};
if [[ $AX_STARTUP_FILE_NAME == ~/.bash_completion ]] && [[ $# -eq 0 ]]; then
    true debug echo "Running in Drop-In Mode ($AX_STARTUP_FILE_NAME)$(tput sgr0)";
    [[ -z $PATH ]] && export PATH="$([[ -d ~/bin ]] && echo $HOME/bin):/bin:/sbin:/usr/bin:/usr/sbin";
    set +o nounset;
    set +xv;
    set +o histexpand;
    set +ET;
    shopt -s extglob;
    shopt -u nullglob;
    shopt -s interactive_comments;
    shopt -s progcomp;
    shopt -s promptvars;
    true debug echo -n "adjusting AX_BASE reference to...";
    export AX_BASE="$(dirname $(readlink -e $BASH_SOURCE))";
    true debug echo -n $AX_BASE;
    if [[ -w $AX_BASE && -d $AX_BASE ]]; then
        true debug echo "... OK";
    else
        echo " ** FAILED TO SET AX_BASE (AX_BASE=\"$AX_BASE\"/PWD=\"$PWD\")";
        echo " ** Please Check All Setups And Try Again!";
        echo " ** stop (1).";
        return 1;
        exit 1;
    fi;
    source "$BASH_SOURCE" prologue --dropin;
    source "$BASH_SOURCE" epilogue;
    return $?;
fi;
if [[ "${AX_PHASES[defined]}" != "yes" ]]; then
    false && declare AX_PROLOGUE AX_EPILOGUE AX_RUNTIME AX_EXIT AX_NONE AX_DEBUG AX_CACHELOAD AX_CACHESTORE;
    declare -rA AX_PHASES=([prologue]="1" [epilogue]="2" [runtime]="3" [exit]="4" [none]="0" [debug]="5" [cacheload]="6" [cachestore]="7" [defined]="yes");
    for xx in ${!AX_PHASES[@]};
    do
        declare -ri AX_${xx^^}=${AX_PHASES[$xx]};
    done;
fi;
declare -i AX_PHASE="${AX_PHASES[$1]}";
[[ $AX_PHASE -eq 0 ]] && { 
    echo "Error: phase was unknown ($1)";
    ax.usage;
    return 1
};
shift;
[[ -v AX_DROP_IN_MODE ]] || declare -g AX_DROP_IN_MODE=0;
if [[ $1 == "--dropin" ]]; then
    declare -g AX_DROP_IN_MODE=1;
    shift;
else
    if [[ $1 == "--reload" ]]; then
        unset AX_BASE;
        echo "RELOADING autox...";
        sleep 1;
        shift;
    else
        if [[ -v AX_BASE ]]; then
            if [[ $AX_PHASE -eq 1 ]]; then
                ax.echo "skipping re-run of autox, it is already run (unset AX_BASE to allow a new run!)";
                return;
            fi;
        fi;
    fi;
fi;
if [[ -n $* ]]; then
    echo "Warning: This version of autox does not allow any more arguments!";
    echo "         proceeding in 2 seconds unless C is pressed!";
    TMOUT=2;
    unset REPLY;
    read -sn1;
    [[ $REPLY -eq C ]] && { 
        echo "Stopped." && return 1
    };
    TMOUT=0;
    set --;
    echo "Continuing with purged command line...";
fi;
if [[ $AX_PHASE == 1 ]]; then
    function ax.echo () 
    { 
        case $1 in 
            on | off)
                case $1 in 
                    on)
                        AX_DEBUGGING=1
                    ;;
                    off)
                        AX_DEBUGGING=0
                    ;;
                esac;
                echo "ax.echo is now $1";
                return 0
            ;;
        esac;
        ((AX_DEBUGGING)) && echo "$@"
    };
    function galias () 
    { 
        ax.checkaliasdir || return 2;
        alias --nolocal "$@"
    };
    function gunalias () 
    { 
        ax.checkaliasdir || return 2;
        unalias --nolocal "$@"
    };
    function lalias () 
    { 
        ax.checkaliasdir || return 2;
        builtin alias "$@"
    };
    function lunalias () 
    { 
        ax.checkaliasdir || return 2;
        builtin unalias "$@"
    };
    function gexport () 
    { 
        ax.checkaliasdir || return 2;
        local EXPCNT=0;
        if [[ $# -gt 0 ]]; then
            for $i in "$@";
            do
                local EXPORTED=0;
                for $j in "${!BASH_ALIASES[@]}";
                do
                    if [[ $i == $j ]]; then
                        builtin alias "$j" >> $AX_BASE/"$i";
                        ax.echo "exported $j";
                        EXPORTED=1;
                    fi;
                done;
                let EXPCNT+=EXPORTED;
                ((EXPORTED)) || echo "alias not found: $i";
            done;
            ax.echo "$EXPCNT alias(es) exported$(let EXPCNT-$# && echo ,\ $[\ EXPCNT-$#\ ]\ skipped. || echo \.)";
        else
            local n=0;
            echo;
            echo "Aliases on $HOSTNAME for $USER($UID):";
            echo;
            for i in $AX_BASE/*;
            do
                ax.echo "$i[30G$(stat $i --format=%s)";
                let n+=1;
            done;
            echo;
            echo "$n aliases.";
            echo;
        fi
    };
    function alias () 
    { 
        declare -gi AX_ALIAS_CALLS;
        if [[ $0 =~ bash ]]; then
            let AX_ALIAS_CALLS++;
        else
            builtin alias "$@";
            return $?;
        fi;
        ax.checkaliasdir && NOGLOB=0 || NOGLOB=1;
        [[ $1 == '--nolocal' ]] && { 
            NOLOC=1;
            shift
        } || NOLOC=0;
        if [[ $# -eq 1 ]]; then
            if [[ $1 =~ = ]]; then
                local NAME="${1%%=*}";
                if [[ ! $NAME =~ ' '+ ]]; then
                    declare -gx LASTALIASSET=$NAME;
                else
                    echo "$NAME - alias name contains illegal characters!";
                    return 1;
                fi;
            else
                if [[ -n ${BASH_ALIASES[$1]} ]]; then
                    builtin alias "$1";
                    return $?;
                else
                    if [[ -r $AX_BASE/alias/$1 ]]; then
                        echo "global version: currently offline";
                        echo "value: $(cat $AX_BASE/alias/$1)";
                        return 1;
                    else
                        echo "no alias, $1, defined global or local";
                        return 1;
                    fi;
                fi;
            fi;
        else
            if [[ $# -eq 0 ]]; then
                builtin alias;
                return $?;
            else
                FINALRET=0;
                for i in "$@";
                do
                    if [[ $i =~ .*=.* ]]; then
                        alias "$i";
                    else
                        if [[ $i == -p ]]; then
                            :;
                        else
                            builtin alias "$i";
                        fi;
                    fi;
                    [[ $? -ne 0 ]] && FINALRET=1;
                done;
                return $FINALRET;
            fi;
        fi;
        if [[ $NOLOC == 0 ]]; then
            builtin alias "$@";
        fi;
        if [[ $NOGLOB == 0 ]]; then
            builtin alias "$NAME" > $AX_BASE/alias/$NAME;
        fi
    };
    function unalias () 
    { 
        if [[ $0 =~ bash ]]; then
            ax.checkaliasdir || return 2;
            local NOLOC=0;
            [[ $1 == '--nolocal' ]] && NOLOC=1;
            if [[ $NOLOC -ne 1 ]]; then
                builtin unalias "$@";
            else
                if [[ $# == 0 ]]; then
                    echo "required: alias name";
                fi;
            fi;
            [[ $# -eq 0 ]] && return;
            if [[ -r $AX_BASEe/alias/$1 ]]; then
                rm $AX_BASE/alias/$1;
                ax.echo "Global alias removed";
            else
                ax.echo "Not global so no global file removed.";
            fi;
        else
            builtin unalias "$@";
            return $?;
        fi
    };
    function ax.contains () 
    { 
        ITEM=$1;
        shift;
        for i in "$@";
        do
            if [[ $i == $ITEM ]]; then
                return 0;
            fi;
        done;
        return 1
    };
    function ax.contains.i () 
    { 
        local NOT_CONTAINS=0;
        while (( $# % 2 == 0 )); do
            ITEM=$1;
            ARRAY_NAME=$2;
            shift 2;
            eval 'ARRAY_VALUES=( "${'$ARRAY_NAME'[@]}" )';
            if ax.contains $ITEM "$@"; then
                echo "$( [[ $INDEX -gt 0 ]] && echo ' ' )$INDEX";
                continue;
            fi;
            echo "$ARRAY_NAME";
            let NOT_CONTAINS++;
        done;
        return $NOT_CONTAINS
    };
    function ax.acquire () 
    { 
        return;
        declare -gA AX_ACQUISITIONS;
        for x in "$@";
        do
            [[ ${x: 0:1} == "<" ]] && [[ ${x: -1:1} == ">" ]] && BRACED=1 || BRACED=0;
            j="${x%%>}";
            i="${j##<}";
            i="${j##[0-9][0-9]}";
            if ax.contains.i AX_ACQUISITIONS "$i"; then
                return 1;
            else
                if [[ $BRACED == 1 ]]; then
                    ITEMS=($(find -L $AX_BASE -iname '$i'));
                    ITEM="${ITEMS[0]}";
                else
                    ITEM="$x";
                fi;
            fi;
            source "$ITEM";
        done
    };
    function ax.load () 
    { 
        ax.checkaliasdir || return 2;
        ALIAS_ITEMS=($(grep -P '^\s*alias \S+=' $AX_BASE/alias/* --line-number | grep '^[^:]*(?=:1)' -P -o));
        ALIAS_CACHE=$(mktemp);
        if [[ ${#ALIAS_ITEMS[@]} -gt 0 ]]; then
            cat ${ALIAS_ITEMS[@]} | sed 's/^alias/builtin alias/g' > $ALIAS_CACHE;
            source $ALIAS_CACHE;
            rm $ALIAS_CACHE;
        else
            echo "Warning: no aliases have been defined in the autox install of $AX_BASE";
        fi
    };
    function ax.checkaliasdir () 
    { 
        [[ -r $AX_BASE/alias/alias.id ]] || { 
            echo "error: AX_BASE not set properly, alias.id missing from alias directory!";
            return 1
        }
    };
    function ax.unload () 
    { 
        ax.checkaliasdir || return 2;
        for i in $AX_BASE/alias/*;
        do
            builtin unalias $(basename $i);
            ax.echo "unloading global alias $i";
        done
    };
    function ax.reload () 
    { 
        if { 
            if [[ -r $AX_BASE/autox ]] && [[ -v AX_BASE ]]; then
                local AX_BASE_TEMP=$AX_BASE;
                unset AX_BASE;
                source "$AX_BASE_TEMP/autox";
            else
                echo "$FUNCNAME: warning - autox AX_BASE not set or not right, loading fresh copy...";
                source "$BASH_SOURCE";
            fi
        }; then
            if [[ -v AX_BASE ]] && [[ -d $AX_BASE/alias ]]; then
                echo "Load succeeded!";
                return 0;
            else
                echo "Load okay, but AX_BASE does not point to a proper location!!! Please check your installation files!!";
                return 1;
            fi;
        else
            echo "Failed! *check your permissions/environment/installation*";
            return 2;
        fi
    };
    function ax.config () 
    { 
        CACHELOAD=0;
        if [[ ! -v CONFIG_CACHE[initialized] ]]; then
            declare -gA CONFIG_CACHE=([initialized]="true");
        fi;
        unset RETV;
        if [[ $1 == cacheok ]]; then
            shift;
            if [[ -n ${CONFIG_CACHE[$*]} ]]; then
                RETV=${CONFIG_CACHE[$*]};
                CACHELOAD=1;
            fi;
        fi;
        declare -gix ax_config_error=0;
        if [[ -v RETV ]] || [[ -r $AX_BASE/config/autoxrc ]]; then
            if [[ -v RETV ]] || RETV=`grep "(?<=^${*}=).*$" -Po $AX_BASE/config/autoxrc`; then
                [[ $CACHELOAD == 0 ]] && CONFIG_CACHE[$*]="$RETV";
                if [[ $RETV =~ ^[0-9]+$ ]]; then
                    return $RETV;
                else
                    echo $RETV;
                    return 1;
                fi;
            else
                CONFIG_CACHE[$*]="1";
                ax_config_error=1;
                return 1;
            fi;
        else
            mkdir -pv --parents $AX_BASE/config;
            touch $AX_BASE/config/autoxrc;
            cat  > $AX_BASE/config/autoxrc <<-EOF
#
# autoxrc
# autox configuration
#
configuration_created=1
EOF

            if (($?)); then
                echo "WARNING: could not create configuration file!";
                tty -s && sleep 2;
            else
                echo "Configuration File Was Created: $AX_BASE/config/autoxrc";
            fi;
        fi
    };
    function ax.config.get () 
    { 
        if ax.config.has $1; then
            VALUE="$(ax.config $1)";
            echo ${VALUE:-$?};
            return 0;
        else
            return 1;
        fi
    };
    function ax.config.has () 
    { 
        ax.config $1 &> /dev/null;
        return $ax_config_error
    };
    function ax.config.set () 
    { 
        if ax.config.has $1; then
            echo "replacing value: $1=$2";
            ax.config.;
        else
            echo "$1=$2" >> $AX_BASE/config/autoxrc;
        fi
    };
    function ax.helperalias () 
    { 
        if [[ ! -v AX_HELPER_ALIASES ]]; then
            declare -gxa AX_HELPER_ALIASES=(`cat $BASH_SOURCE | grep '^ax\.[^\( ]+' -Po`);
        fi;
        if [[ $# -gt 1 ]]; then
            for item in "$@";
            do
                ax.helperalias "$item";
            done;
        else
            if [[ $# -eq 1 ]]; then
                NAME="${*%%=*}";
                OVERWRITE=NO;
                for i in "${AX_HELPER_ALIASES[@]}";
                do
                    if [[ "$i" == "$NAME" ]]; then
                        echo "Warning, This ax.helper alias is being overwritten: $i";
                        OVERWRITE=YES;
                    else
                        if ax.config cacheok debug_helperalias; then
                            echo "debug: ax.helper $i being set for first time ok";
                        fi;
                    fi;
                done;
                builtin alias "$@";
                [[ $OVERWRITE == NO ]] && AX_HELPER_ALIASES+=($NAME);
            else
                echo -e "builtin helper aliases:\n";
                if [[ -v AX_HELPER_ALIASES ]]; then
                    local -i n=0;
                    for i in ${AX_HELPER_ALIASES[@]};
                    do
                        echo -e "\t$i";
                        let n++;
                    done;
                    echo -e "\n$n alias(es).\n";
                else
                    echo -e "\t<<NONE>>\n\nZero alias(es).\n";
                fi;
            fi;
        fi
    };
    [[ $AX_DROP_IN_MODE -eq 1 ]] || AX_BASE="$(realpath $(dirname $BASH_SOURCE))";
    { 
        ax.helperalias stub=function;
        ax.helperalias ro=readonly;
        ax.helperalias int='declare -i';
        ax.helperalias list='declare -a';
        ax.helperalias hash='declare -A';
        ax.helperalias islist='declare -pa';
        ax.helperalias ishash='declare -pA';
        ax.helperalias ax.echoa='echo ${!BASH_ALIASES[*]}';
        ax.helperalias next=done;
        ax.helperalias endif=fi;
        ax.helperalias elseif=elif;
        ax.helperalias endselect=done;
        ax.helperalias endwhile=done;
        ax.helperalias enduntil=done
    };
    if [[ ! -v AX_SESSION_ID ]] && [[ -d $AX_BASE ]] && [[ -r $AX_BASE/autox ]]; then
        AX_SESSION_ID_PREFIX="$USER:$GROUP:";
    fi;
    if command xprop -root 2> /dev/null | grep --color=auto _NET_ACTIVE_WINDOW -q; then
        eval $(ps -p $(xprop -id `xprop -root -notype | grep -Po '(?<=_NET_ACTIVE_WINDOW: window id # )[[:xdigit:]x]+'` | grep PID | grep '[[:digit:]]*' -o) --no-header -o "AX_TERMINAL=\"%c\" AX_TERMINAL_PID=\"%p\"" | sed -r 's/(")( *)([^ ]+)( *)(")/\1\3\5/g');
    else
        if [[ $TTY =~ /dev/tty ]]; then
            AX_TERMINAL=hardware;
        else
            if [[ $TTY =~ /dev/.*pt ]]; then
                AX_TERMINAL=ptmx_ssh;
            else
                AX_TERMINAL=special;
            fi;
        fi;
        AX_TERMINAL_PID=$$;
        AX_TERMINAL_PPID=$PPID;
    fi;
    ax.load;
else
    if [[ $AX_PHASE == 2 ]]; then
        for i in $AX_BASE/bootstrap.d/*.ax;
        do
            true extdebug echo "-------------- BOOTSTRAPPER $i ------------ ";
            if [[ -s "$i" ]]; then
                ax.echo $(declare -p BASH_SOURCE | sed 's/declare\s?//g') source "$i" "$$" "$USER" "$AX_BASE";
                . "$i" "$$" "$USER" "$AX_BASE";
            fi;
            true extdebug echo "----------- END BOOTSTRAPPER $i ----------- ";
        done;
    else
        if [[ $AX_PHASE -le 4 ]]; then
            echo "runtime and exit phases are not yet supported, doing nothing successfully (0)...";
            return 0;
        else
            echo "Unsupported phase: $AX_PHASE";
            return 122;
        fi;
    fi;
fi;
set +o nounset;
set +EHxvT;
if ax.config.has hatewhitespace; then
    true "";
else
    echo "";
fi
