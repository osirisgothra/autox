ACTIVEPERL_MODE=0
ALIAS_CACHE=/tmp/tmp.2NrydoJ32Z
ALIAS_ITEMS=([0]="/src/ax/alias/a" [1]="/src/ax/alias/ac" [2]="/src/ax/alias/aclear" [3]="/src/ax/alias/alert" [4]="/src/ax/alias/apt-builds" [5]="/src/ax/alias/apt-get" [6]="/src/ax/alias/apt-source" [7]="/src/ax/alias/apt-upgrade" [8]="/src/ax/alias/arg1" [9]="/src/ax/alias/argtest" [10]="/src/ax/alias/ark" [11]="/src/ax/alias/arora" [12]="/src/ax/alias/autox" [13]="/src/ax/alias/ax.echoa" [14]="/src/ax/alias/ax.kde.control" [15]="/src/ax/alias/ax.reloader" [16]="/src/ax/alias/b" [17]="/src/ax/alias/bar" [18]="/src/ax/alias/beep.off" [19]="/src/ax/alias/beep.on" [20]="/src/ax/alias/beep.toggle" [21]="/src/ax/alias/bluroff" [22]="/src/ax/alias/bluron" [23]="/src/ax/alias/blurtgl" [24]="/src/ax/alias/bye" [25]="/src/ax/alias/c" [26]="/src/ax/alias/clem" [27]="/src/ax/alias/colortable" [28]="/src/ax/alias/_comp_sf" [29]="/src/ax/alias/cpan" [30]="/src/ax/alias/cpln" [31]="/src/ax/alias/define" [32]="/src/ax/alias/df" [33]="/src/ax/alias/dolphin" [34]="/src/ax/alias/du" [35]="/src/ax/alias/duu" [36]="/src/ax/alias/egrep" [37]="/src/ax/alias/elseif" [38]="/src/ax/alias/endif" [39]="/src/ax/alias/endselect" [40]="/src/ax/alias/enduntil" [41]="/src/ax/alias/endwhile" [42]="/src/ax/alias/executables" [43]="/src/ax/alias/executables~" [44]="/src/ax/alias/fgrep" [45]="/src/ax/alias/firefox" [46]="/src/ax/alias/fo" [47]="/src/ax/alias/foo" [48]="/src/ax/alias/free" [49]="/src/ax/alias/freeup" [50]="/src/ax/alias/goo" [51]="/src/ax/alias/goodnight" [52]="/src/ax/alias/goto" [53]="/src/ax/alias/grep" [54]="/src/ax/alias/hash" [55]="/src/ax/alias/hib" [56]="/src/ax/alias/htop" [57]="/src/ax/alias/idle" [58]="/src/ax/alias/int" [59]="/src/ax/alias/ip" [60]="/src/ax/alias/ipython" [61]="/src/ax/alias/ishash" [62]="/src/ax/alias/islist" [63]="/src/ax/alias/j" [64]="/src/ax/alias/jobs" [65]="/src/ax/alias/kill" [66]="/src/ax/alias/komodo" [67]="/src/ax/alias/l" [68]="/src/ax/alias/la" [69]="/src/ax/alias/link" [70]="/src/ax/alias/links" [71]="/src/ax/alias/list" [72]="/src/ax/alias/ll" [73]="/src/ax/alias/ln" [74]="/src/ax/alias/locate" [75]="/src/ax/alias/ls" [76]="/src/ax/alias/makeduid" [77]="/src/ax/alias/makelic" [78]="/src/ax/alias/makepercpp" [79]="/src/ax/alias/makepercpp_cleanall" [80]="/src/ax/alias/makepercpp_targets" [81]="/src/ax/alias/man" [82]="/src/ax/alias/mann" [83]="/src/ax/alias/med" [84]="/src/ax/alias/mem" [85]="/src/ax/alias/merge" [86]="/src/ax/alias/mergedirs" [87]="/src/ax/alias/mkdir" [88]="/src/ax/alias/modin" [89]="/src/ax/alias/modout" [90]="/src/ax/alias/mvln" [91]="/src/ax/alias/n" [92]="/src/ax/alias/nano" [93]="/src/ax/alias/ned" [94]="/src/ax/alias/next" [95]="/src/ax/alias/nls" [96]="/src/ax/alias/noisefortune4" [97]="/src/ax/alias/normal" [98]="/src/ax/alias/of" [99]="/src/ax/alias/okular" [100]="/src/ax/alias/pc" [101]="/src/ax/alias/perlconsole" [102]="/src/ax/alias/pgrep" [103]="/src/ax/alias/ph" [104]="/src/ax/alias/phash" [105]="/src/ax/alias/pkgconf" [106]="/src/ax/alias/pycharm" [107]="/src/ax/alias/qbittorrent" [108]="/src/ax/alias/qtcreator" [109]="/src/ax/alias/realtime" [110]="/src/ax/alias/rem" [111]="/src/ax/alias/rmpwd" [112]="/src/ax/alias/ro" [113]="/src/ax/alias/s" [114]="/src/ax/alias/sbax.off" [115]="/src/ax/alias/sbax.on" [116]="/src/ax/alias/second" [117]="/src/ax/alias/service" [118]="/src/ax/alias/sf" [119]="/src/ax/alias/startx" [120]="/src/ax/alias/stub" [121]="/src/ax/alias/stubfunc" [122]="/src/ax/alias/subl" [123]="/src/ax/alias/sunlink" [124]="/src/ax/alias/suspend" [125]="/src/ax/alias/svcstats" [126]="/src/ax/alias/thendo" [127]="/src/ax/alias/top" [128]="/src/ax/alias/tputtest" [129]="/src/ax/alias/tree" [130]="/src/ax/alias/unlink" [131]="/src/ax/alias/webstorm" [132]="/src/ax/alias/xchg" [133]="/src/ax/alias/xclip" [134]="/src/ax/alias/xprop" [135]="/src/ax/alias/xprop2")
AXBM=pre
AXOPT='?'
AX_BASE=/src/ax
AX_CACHELOAD=6
AX_CACHESTORE=7
AX_CACHE_SHA_SIZE=512
AX_CACHE_SITE=/src/ax/cache/usecache
AX_DEBUG=5
AX_DEFINED=0
AX_DESCRIPTION=([/src/ax/bootstrap.d/compbind.ax]="" )
AX_DROP_IN_MODE=1
AX_EPILOGUE=2
AX_EXIT=4
AX_FUNCS=([chmog]="/src/ax/func/chmog.af" [date]="/src/ax/func/date.af" [silent]="/src/ax/func/silent.af" )
AX_FUNC_CMPMODE=or
AX_FUNC_CMPMODES=([and]="&" [or]="|" )
AX_HELPER_ALIASES=([0]="ax.cache.create" [1]="ax.updatecache" [2]="ax.echo" [3]="ax.contains" [4]="ax.contains.i" [5]="ax.acquire" [6]="ax.load" [7]="ax.checkaliasdir" [8]="ax.unload" [9]="ax.reload" [10]="ax.config" [11]="ax.config.get" [12]="ax.config.has" [13]="ax.config.set" [14]="ax.helperalias" [15]="stub" [16]="ro" [17]="int" [18]="list" [19]="hash" [20]="islist" [21]="ishash" [22]="ax.echoa" [23]="next" [24]="endif" [25]="elseif" [26]="endselect" [27]="endwhile" [28]="enduntil")
AX_MACROS_LOADED=2070
AX_NONE=0
AX_ONE_TIME_MESSAGES=([NOCACHE]="1" )
AX_ON_XSESSION=no
AX_PHASE=2
AX_PHASES=([cacheload]="6" [none]="0" [prologue]="1" [debug]="5" [exit]="4" [epilogue]="2" [cachestore]="7" [runtime]="3" [defined]="yes" )
AX_PREFIXER_DEBUG_THRESHOLD=4
AX_PREFIXER_LOAD_COUNT=1
AX_PROLOGUE=1
AX_RUNTIME=3
AX_SESSION_ID_PREFIX=gabriel::
AX_STARTUP_FILE_NAME=/home/gabriel/.bash_completion
AX_TERMINAL=konsole
AX_TERMINAL_PID=2062
AX_USER_BASHRC_ORIGINATED=1
AX_USER_BASHRC_ORIGIN_COUNT=3
AX_USER_VARS_INITIALIZED=1
BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:histappend:interactive_comments:progcomp:promptvars:sourcepath
BASH_ALIASES=()
BASH_ARGC=()
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION_COMPAT_DIR=/etc/bash_completion.d
BASH_LINENO=([0]="17" [1]="1")
BASH_REMATCH=()
BASH_SOURCE=([0]="/home/gabriel/.bash_completion" [1]="/home/gabriel/.bash_completion")
BASH_VERSINFO=([0]="4" [1]="3" [2]="39" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
BASH_VERSION='4.3.39(1)-release'
BG='tput setab'
BOLD=$'\E[1m'
BUL=$'\E[1m*\E(B\E[m'
CACHELOAD=0
CLUTTER_IM_MODULE=xim
CNFHDEFINED=1
COLORFGBG='15;0'
COLUMNS=127
CONFIG_CACHE=([initialized]="true" [perl_mode_paths]="1" [custom_terminal]="1" [hatewhitespace]="1" [debug_helperalias]="1" )
DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-xl3tIzaMOu,guid=de0f59658c276494df7f620055e25242
DEFAULTS_PATH=/usr/share/gconf/plasma.default.path
DESKTOP_SESSION=plasma
DIRSTACK=()
DISPLAY=:0
EUID=1000
FG='tput setaf'
FUNCNAME=([0]="_ax__generate_values" [1]="ax.cache.create")
GLOF2=Ctrl+F2
GLOF2_B=$'\E[1;2Q'
GLOF2_k=kf14
GPG_AGENT_INFO=/tmp/gpg-csoz1Y/S.gpg-agent:1327:1
GROUPS=()
GS_LIB=/home/gabriel/.fonts
GTK2_RC_FILES=/etc/gtk-2.0/gtkrc:/home/gabriel/.gtkrc-2.0:/home/gabriel/.config/gtkrc-2.0
GTK_IM_MODULE=fcitx
GTK_RC_FILES=/etc/gtk/gtkrc:/home/gabriel/.gtkrc:/home/gabriel/.config/gtkrc
HISTCONTROL=ignoredups
HISTFILE=/home/gabriel/.bash_history
HISTFILESIZE=-1
HISTSIZE=-1
HOME=/home/gabriel
HOSTNAME=larnica
HOSTTYPE=x86_64
IFS=$' \t\n'
KDE_FULL_SESSION=true
KDE_MULTIHEAD=false
KDE_SESSION_UID=1000
KDE_SESSION_VERSION=5
KONSOLE_DBUS_SERVICE=:1.48
KONSOLE_DBUS_SESSION=/Sessions/1
KONSOLE_DBUS_WINDOW=/Windows/1
KONSOLE_PROFILE_NAME=Shell
LANG=en_US.UTF-8
LANGUAGE=en_US
LAST=7
LESSCLOSE='/usr/bin/lesspipe %s %s'
LESSOPEN='| /usr/bin/lesspipe %s'
LINES=29
LOCF2=F2
LOCF2_B=$'\EOQ'
LOCF2_k=kf2
LOGNAME=gabriel
LS_COLORS='no=00:fi=00:rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.sh=01;32:*.csh=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:'
MACHTYPE=x86_64-pc-linux-gnu
MAILCHECK=60
MANDATORY_PATH=/usr/share/gconf/plasma.mandatory.path
NAME=enduntil
NOUNSET=1
OERR=1
OFF=$'\E(B\E[m'
OLDPWD=/src/ax
OPTERR=1
OPTIND=2
OSTYPE=linux-gnu
OVERWRITE=NO
PAM_KWALLET_LOGIN=/tmp/kwallet_gabriel.socket
PATH=/home/gabriel/.local/bin:/usr/local/bin:/src/mini/eso/ubin:/src/mini/eso/ubin-local:/gxbase/bin:/gxbase/lib:/gxbase/tools:/home/gabriel/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/opt/webstorm/bin:/opt/clion/bin:/opt/pycharm/bin
PERCENT=0
PERLMODELIB=([0]="" [1]="/opt/activeperl/lib")
PERLMODEPATH=([0]="/home/gabriel/.local/bin:/usr/local/bin:/src/mini/eso/ubin:/src/mini/eso/ubin-local:/gxbase/bin:/gxbase/lib:/gxbase/tools:/home/gabriel/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/opt/webstorm/bin:/opt/clion/bin:/opt/pycharm/bin" [1]="/opt/activeperl/bin:/home/gabriel/.local/bin:/usr/local/bin:/src/mini/eso/ubin:/src/mini/eso/ubin-local:/gxbase/bin:/gxbase/lib:/gxbase/tools:/home/gabriel/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/opt/webstorm/bin:/opt/clion/bin:/opt/pycharm/bin")
PERLTOGGLEMODE='(2 alternatives configured!)'
PIPESTATUS=([0]="0")
PPID=2062
PROCS=([alias]="builtin alias -p" [value]="builtin declare" [hash]="hash -l" [shasum]="shasum \$AX_CACHE_SITE/!(shasum.act) -a \$AX_CACHE_SHA_SIZE" [binding]="builtin bind -psvX" [trap]="trap -l" [option]="shopt -p; shopt -po" [completion]="builtin complete" )
PROFILEHOME=
PROMPTFACTORY_HELP_BAD_EDITOR='error: editor failed - '
PROMPTFACTORY_HELP_BAD_OPTION='error: Unknown Option:'
PROMPTFACTORY_HELP_END='mo[r]e [i]nfo, contac[t]'
PROMPTFACTORY_HELP_START='u[s]ag[e]:'
PROMPTFACTORY_HELP_TRIMLEADINGCHARCOUNT=1
PS1='\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
PS2='> '
PS4='+ '
PWD=/src/ax
QT4_IM_MODULE=fcitx
QT_IM_MODULE=fcitx
READLINE_LINE=
READLINE_POINT=0
RETV=
SESSION_MANAGER=local/larnica:@/tmp/.ICE-unix/1530,unix/larnica:/tmp/.ICE-unix/1530
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:history:interactive-comments:monitor
SHELL_SESSION_ID=8865cbdb7fe94000936f4fa8a36aa933
SHLVL=1
SSH_AGENT_PID=1326
SSH_AUTH_SOCK=/tmp/ssh-tVTRVDNZ3VUg/agent.1252
STEP=0
STEPF=/src/ax/cache/usecache/value.act
STEPS=([0]="value" [1]="binding" [2]="alias" [3]="completion" [4]="option" [5]="hash" [6]="trap" [7]="shasum")
TERM=xterm-256color
TMPFILE=/tmp/tmp.gmUj0ZDWSy
TTY=/dev/pts/0
UID=1000
USER=gabriel
WINDOWID=54525958
XAUTHORITY=/tmp/xauth-1000-_0
XCURSOR_SIZE=0
XCURSOR_THEME=breeze_cursors
XDG_CONFIG_DIRS=/etc/xdg/xdg-plasma:/etc/xdg:/usr/share/kubuntu-default-settings/kf5-settings
XDG_CURRENT_DESKTOP=KDE
XDG_DATA_DIRS=/usr/share/plasma:/usr/local/share/:/usr/share/
XDG_RUNTIME_DIR=/run/user/1000
XDG_SEAT=seat0
XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0
XDG_SESSION_CLASS=user
XDG_SESSION_COOKIE=e8debfca2f7d4cd395e446b01f961ace-1440895554.122197-1268994903
XDG_SESSION_DESKTOP=KDE
XDG_SESSION_ID=2
XDG_SESSION_PATH=/org/freedesktop/DisplayManager/Session1
XDG_SESSION_TYPE=x11
XDG_VTNR=7
XMODIFIERS=@im=fcitx
_='STEPF="$AX_CACHE_SITE/${STEPS[$STEP]}.act"'
__git_printf_supports_v=yes
__grub_script_check_program=grub-script-check
_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|dpkg*|rpm@(orig|new|save))))'
_xspecs=([freeamp]="!*.@(mp3|og[ag]|pls|m3u)" [cdiff]="!*.@(dif?(f)|?(d)patch)?(.@([gx]z|bz2|lzma))" [bibtex]="!*.aux" [rgview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [oowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm)" [chromium-browser]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [tex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [zathura]="!*.@(cb[rz7t]|djv?(u)|?(e)ps|pdf)" [netscape]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [acroread]="!*.[pf]df" [makeinfo]="!*.texi*" [kwrite]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [gview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [qiv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|svg)" [lrunzip]="!*.lrz" [bzcat]="!*.?(t)bz?(2)" [amaya]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [pdftex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [hbpp]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [rpm2cpio]="!*.[rs]pm" [view]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [unxz]="!*.@(?(t)xz|tlz|lzma)" [ly2dvi]="!*.ly" [mozilla]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [modplugplay]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|okta|p[st]m|s[3t]m|ult|umx|wav|xm)" [lzgrep]="!*.@(tlz|lzma)" [pyflakes]="!*.py" [dillo]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [aaxine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [dvipdfmx]="!*.dvi" [advi]="!*.dvi" [ggv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [lzmore]="!*.@(tlz|lzma)" [lzless]="!*.@(tlz|lzma)" [kdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [poedit]="!*.po" [firefox]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [madplay]="!*.mp3" [lbzcat]="!*.?(t)bz?(2)" [lilypond]="!*.ly" [gtranslator]="!*.po" [jadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [sxemacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [epdfview]="!*.pdf" [gpdf]="!*.[pf]df" [kghostview]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [pbzcat]="!*.?(t)bz?(2)" [texi2dvi]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [ps2pdf12]="!*.@(?(e)ps|pdf)" [ee]="!*.@(gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx)" [lzcat]="!*.@(tlz|lzma)" [lbunzip2]="!*.?(t)bz?(2)" [ps2pdf13]="!*.@(?(e)ps|pdf)" [vim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [ps2pdf14]="!*.@(?(e)ps|pdf)" [dvips]="!*.dvi" [lzfgrep]="!*.@(tlz|lzma)" [hbrun]="!*.[Hh][Rr][Bb]" [kbabel]="!*.po" [rview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kaffeine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.part)" [xv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|?(e)ps)" [rgvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dvitype]="!*.dvi" [oodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [elinks]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [playmidi]="!*.@(mid?(i)|cmf)" [realplay]="!*.@(rm?(j)|ra?(m)|smi?(l))" [xine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [xpdf]="!*.@(pdf|fdf)?(.@(gz|xz|Z|bz2))" [gqmpeg]="!*.@(mp3|og[ag]|pls|m3u)" [lzegrep]="!*.@(tlz|lzma)" [aviplay]="!*.@(avi|asf|wmv)" [latex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [rvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [bunzip2]="!*.?(t)bz?(2)" [ogg123]="!*.@(og[ag]|m3u|flac|spx)" [ps2pdfwr]="!*.@(?(e)ps|pdf)" [znew]="*.Z" [harbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lokalize]="!*.po" [kate]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [xemacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dragon]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.part)" [unlzma]="!*.@(tlz|lzma)" [pdflatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [vi]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [mozilla-firefox]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [ooimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [gvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [uncompress]="!*.Z" [kid3-qt]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [xanim]="!*.@(mpg|mpeg|avi|mov|qt)" [unpigz]="!*.@(Z|[gGd]z|t[ag]z)" [portecle]="!@(*.@(ks|jks|jceks|p12|pfx|bks|ubr|gkr|cer|crt|cert|p7b|pkipath|pem|p10|csr|crl)|cacerts)" [oocalc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [emacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [fbxine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [lynx]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [ps2pdf]="!*.@(?(e)ps|pdf)" [kpdf]="!*.@(?(e)ps|pdf)" [oomath]="!*.@(sxm|smf|mml|odf)" [compress]="*.Z" [iceweasel]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [mpg321]="!*.mp3" [mpg123]="!*.mp3" [zcat]="!*.@(Z|[gGd]z|t[ag]z)" [unzip]="!*.@(zip|[ejsw]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|do[ct][xm]|p[op]t[mx]|xl[st][xm])" [pbunzip2]="!*.?(t)bz?(2)" [kid3]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [pdfjadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [dvipdf]="!*.dvi" [gharbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [modplug123]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|okta|p[st]m|s[3t]m|ult|umx|wav|xm)" [dvipdfm]="!*.dvi" [oobase]="!*.odb" [texi2html]="!*.texi*" [zipinfo]="!*.@(zip|[ejsw]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|do[ct][xm]|p[op]t[mx]|xl[st][xm])" [epiphany]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gunzip]="!*.@(Z|[gGd]z|t[ag]z)" [google-chrome]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [okular]="!*.@(okular|@(?(e|x)ps|?(E|X)PS|[pf]df|[PF]DF|dvi|DVI|cb[rz]|CB[RZ]|djv?(u)|DJV?(U)|dvi|DVI|gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX|epub|EPUB|odt|ODT|fb?(2)|FB?(2)|mobi|MOBI|g3|G3|chm|CHM)?(.?(gz|GZ|bz2|BZ2)))" [slitex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [galeon]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [bzme]="!*.@(zip|z|gz|tgz)" [xfig]="!*.fig" [xzcat]="!*.@(?(t)xz|tlz|lzma)" [timidity]="!*.@(mid?(i)|rmi|rcp|[gr]36|g18|mod|xm|it|x3m|s[3t]m|kar)" [dviselect]="!*.dvi" [xdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" )
ax_config_error=1
fname=/src/ax/func/silent.af
i=/src/ax/bootstrap.d/utf8_linux_console.ax
incrementer='let STEP++ "PERCENT=STEP*100/LAST"; echo -e "\E8${STEPS[$STEP]}s... ($PERCENT% completed)\E[J"; STEPF="$AX_CACHE_SITE/${STEPS[$STEP]}.act"'
x=/home/gabriel/.bashrc
xx=defined
RGB () 
{ 
    if [[ $# -lt 3 ]]; then
        if [[ $(caller) =~ $FUNCNAME ]]; then
            echo "$FUNCNAME: Fatal: <=2 args for -- stopping at second recursion ($(caller))";
            return 2;
        fi;
        case $# in 
            2)
                RGB ${1//,/ } ${@: 2}
            ;;
            1)
                RGB ${1//,/ }
            ;;
            *)
                echo "Error in SGR Call: RGB Codes Must Be Separated by Commas(,) or Spaces( )";
                return 1
            ;;
        esac;
        return;
    fi;
    local -i R=$1;
    G=$2;
    B=$3;
    F=${4-f};
    local -i RSL;
    let 'RSL = R | (G<<3) | (B<<7)';
    case ${F} in 
        f | b)
            tput seta${F} ${RSL}
        ;;
        a)
            for x in f b;
            do
                tput seta${x} ${RSL};
            done
        ;;
        *)
            tput ${F} ${RSL}
        ;;
    esac
}
__all_modules () 
{ 
    while read name; do
        name=${name%% *};
        printf "%s\n" "$name";
    done < <(pulseaudio --dump-modules 2> /dev/null)
}
__cards () 
{ 
    while IFS='	' read idx name _; do
        printf "%s %s\n" "$idx" "$name";
    done < <(pactl list cards short 2> /dev/null)
}
__expand_tilde_by_ref () 
{ 
    if [[ ${!1} == \~* ]]; then
        if [[ ${!1} == */* ]]; then
            eval $1="${!1/%\/*}"/'${!1#*/}';
        else
            eval $1="${!1}";
        fi;
    fi
}
__func () 
{ 
    case $1 in 
        *=*)
            source /dev/stdin  <<EOF
				function ${1/=*}()
				{
					$(echo ${1/*=})
				}
EOF

            declare -pf ${1/=*} > $AX_BASE/func/${1/=*}.af
        ;;
        *)
            if [[ -n "${AX_FUNCS[$1]}" ]]; then
                printf "func $1='%s'" "$(declare -pf "$1" | head -n-1 | tail -n+3)";
            else
                echo "Unknown func ($1)";
            fi
        ;;
    esac
}
__func_loader () 
{ 
    local NONULLGLOB=0;
    shopt -q nullglob || NONULLGLOB=1;
    shopt -s nullglob;
    for fname in $AX_BASE/func/*.af;
    do
        source "$fname";
        local FNAME=$(basename $fname | sed 's/\.af$//g' );
        AX_FUNCS[$FNAME]="$fname";
    done;
    [[ $NONULLGLOB -eq 1 ]] && shopt -u nullglob
}
__get_cword_at_cursor_by_ref () 
{ 
    local cword words=();
    __reassemble_comp_words_by_ref "$1" words cword;
    local i cur index=$COMP_POINT lead=${COMP_LINE:0:$COMP_POINT};
    if [[ $index -gt 0 && ( -n $lead && -n ${lead//[[:space:]]} ) ]]; then
        cur=$COMP_LINE;
        for ((i = 0; i <= cword; ++i ))
        do
            while [[ ${#cur} -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                cur="${cur:1}";
                ((index--));
            done;
            if [[ $i -lt $cword ]]; then
                local old_size=${#cur};
                cur="${cur#"${words[i]}"}";
                local new_size=${#cur};
                index=$(( index - old_size + new_size ));
            fi;
        done;
        [[ -n $cur && ! -n ${cur//[[:space:]]} ]] && cur=;
        [[ $index -lt 0 ]] && index=0;
    fi;
    local "$2" "$3" "$4" && _upvars -a${#words[@]} $2 "${words[@]}" -v $3 "$cword" -v $4 "${cur:0:$index}"
}
__git_eread () 
{ 
    local f="$1";
    shift;
    test -r "$f" && read "$@" < "$f"
}
__git_ps1 () 
{ 
    local exit=$?;
    local pcmode=no;
    local detached=no;
    local ps1pc_start='\u@\h:\w ';
    local ps1pc_end='\$ ';
    local printf_format=' (%s)';
    case "$#" in 
        2 | 3)
            pcmode=yes;
            ps1pc_start="$1";
            ps1pc_end="$2";
            printf_format="${3:-$printf_format}";
            PS1="$ps1pc_start$ps1pc_end"
        ;;
        0 | 1)
            printf_format="${1:-$printf_format}"
        ;;
        *)
            return $exit
        ;;
    esac;
    local ps1_expanded=yes;
    [ -z "$ZSH_VERSION" ] || [[ -o PROMPT_SUBST ]] || ps1_expanded=no;
    [ -z "$BASH_VERSION" ] || shopt -q promptvars || ps1_expanded=no;
    local repo_info rev_parse_exit_code;
    repo_info="$(git rev-parse --git-dir --is-inside-git-dir 		--is-bare-repository --is-inside-work-tree 		--short HEAD 2>/dev/null)";
    rev_parse_exit_code="$?";
    if [ -z "$repo_info" ]; then
        return $exit;
    fi;
    local short_sha;
    if [ "$rev_parse_exit_code" = "0" ]; then
        short_sha="${repo_info##*
}";
        repo_info="${repo_info%
*}";
    fi;
    local inside_worktree="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local bare_repo="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local inside_gitdir="${repo_info##*
}";
    local g="${repo_info%
*}";
    if [ "true" = "$inside_worktree" ] && [ -n "${GIT_PS1_HIDE_IF_PWD_IGNORED-}" ] && [ "$(git config --bool bash.hideIfPwdIgnored)" != "false" ] && git check-ignore -q .; then
        return $exit;
    fi;
    local r="";
    local b="";
    local step="";
    local total="";
    if [ -d "$g/rebase-merge" ]; then
        __git_eread "$g/rebase-merge/head-name" b;
        __git_eread "$g/rebase-merge/msgnum" step;
        __git_eread "$g/rebase-merge/end" total;
        if [ -f "$g/rebase-merge/interactive" ]; then
            r="|REBASE-i";
        else
            r="|REBASE-m";
        fi;
    else
        if [ -d "$g/rebase-apply" ]; then
            __git_eread "$g/rebase-apply/next" step;
            __git_eread "$g/rebase-apply/last" total;
            if [ -f "$g/rebase-apply/rebasing" ]; then
                __git_eread "$g/rebase-apply/head-name" b;
                r="|REBASE";
            else
                if [ -f "$g/rebase-apply/applying" ]; then
                    r="|AM";
                else
                    r="|AM/REBASE";
                fi;
            fi;
        else
            if [ -f "$g/MERGE_HEAD" ]; then
                r="|MERGING";
            else
                if [ -f "$g/CHERRY_PICK_HEAD" ]; then
                    r="|CHERRY-PICKING";
                else
                    if [ -f "$g/REVERT_HEAD" ]; then
                        r="|REVERTING";
                    else
                        if [ -f "$g/BISECT_LOG" ]; then
                            r="|BISECTING";
                        fi;
                    fi;
                fi;
            fi;
        fi;
        if [ -n "$b" ]; then
            :;
        else
            if [ -h "$g/HEAD" ]; then
                b="$(git symbolic-ref HEAD 2>/dev/null)";
            else
                local head="";
                if ! __git_eread "$g/HEAD" head; then
                    return $exit;
                fi;
                b="${head#ref: }";
                if [ "$head" = "$b" ]; then
                    detached=yes;
                    b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" || b="$short_sha...";
                    b="($b)";
                fi;
            fi;
        fi;
    fi;
    if [ -n "$step" ] && [ -n "$total" ]; then
        r="$r $step/$total";
    fi;
    local w="";
    local i="";
    local s="";
    local u="";
    local c="";
    local p="";
    if [ "true" = "$inside_gitdir" ]; then
        if [ "true" = "$bare_repo" ]; then
            c="BARE:";
        else
            b="GIT_DIR!";
        fi;
    else
        if [ "true" = "$inside_worktree" ]; then
            if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
                git diff --no-ext-diff --quiet --exit-code || w="*";
                if [ -n "$short_sha" ]; then
                    git diff-index --cached --quiet HEAD -- || i="+";
                else
                    i="#";
                fi;
            fi;
            if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && git rev-parse --verify --quiet refs/stash > /dev/null; then
                s="$";
            fi;
            if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] && git ls-files --others --exclude-standard --error-unmatch -- ':/*' > /dev/null 2> /dev/null; then
                u="%${ZSH_VERSION+%}";
            fi;
            if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
                __git_ps1_show_upstream;
            fi;
        fi;
    fi;
    local z="${GIT_PS1_STATESEPARATOR-" "}";
    if [ $pcmode = yes ] && [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then
        __git_ps1_colorize_gitstring;
    fi;
    b=${b##refs/heads/};
    if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then
        __git_ps1_branch_name=$b;
        b="\${__git_ps1_branch_name}";
    fi;
    local f="$w$i$s$u";
    local gitstring="$c$b${f:+$z$f}$r$p";
    if [ $pcmode = yes ]; then
        if [ "${__git_printf_supports_v-}" != yes ]; then
            gitstring=$(printf -- "$printf_format" "$gitstring");
        else
            printf -v gitstring -- "$printf_format" "$gitstring";
        fi;
        PS1="$ps1pc_start$gitstring$ps1pc_end";
    else
        printf -- "$printf_format" "$gitstring";
    fi;
    return $exit
}
__git_ps1_colorize_gitstring () 
{ 
    if [[ -n ${ZSH_VERSION-} ]]; then
        local c_red='%F{red}';
        local c_green='%F{green}';
        local c_lblue='%F{blue}';
        local c_clear='%f';
    else
        local c_red='\[\e[31m\]';
        local c_green='\[\e[32m\]';
        local c_lblue='\[\e[1;34m\]';
        local c_clear='\[\e[0m\]';
    fi;
    local bad_color=$c_red;
    local ok_color=$c_green;
    local flags_color="$c_lblue";
    local branch_color="";
    if [ $detached = no ]; then
        branch_color="$ok_color";
    else
        branch_color="$bad_color";
    fi;
    c="$branch_color$c";
    z="$c_clear$z";
    if [ "$w" = "*" ]; then
        w="$bad_color$w";
    fi;
    if [ -n "$i" ]; then
        i="$ok_color$i";
    fi;
    if [ -n "$s" ]; then
        s="$flags_color$s";
    fi;
    if [ -n "$u" ]; then
        u="$bad_color$u";
    fi;
    r="$c_clear$r"
}
__git_ps1_show_upstream () 
{ 
    local key value;
    local svn_remote svn_url_pattern count n;
    local upstream=git legacy="" verbose="" name="";
    svn_remote=();
    local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')";
    while read -r key value; do
        case "$key" in 
            bash.showupstream)
                GIT_PS1_SHOWUPSTREAM="$value";
                if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
                    p="";
                    return;
                fi
            ;;
            svn-remote.*.url)
                svn_remote[$((${#svn_remote[@]} + 1))]="$value";
                svn_url_pattern="$svn_url_pattern\\|$value";
                upstream=svn+git
            ;;
        esac;
    done <<< "$output";
    for option in ${GIT_PS1_SHOWUPSTREAM};
    do
        case "$option" in 
            git | svn)
                upstream="$option"
            ;;
            verbose)
                verbose=1
            ;;
            legacy)
                legacy=1
            ;;
            name)
                name=1
            ;;
        esac;
    done;
    case "$upstream" in 
        git)
            upstream="@{upstream}"
        ;;
        svn*)
            local -a svn_upstream;
            svn_upstream=($(git log --first-parent -1 					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null));
            if [[ 0 -ne ${#svn_upstream[@]} ]]; then
                svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]};
                svn_upstream=${svn_upstream%@*};
                local n_stop="${#svn_remote[@]}";
                for ((n=1; n <= n_stop; n++))
                do
                    svn_upstream=${svn_upstream#${svn_remote[$n]}};
                done;
                if [[ -z "$svn_upstream" ]]; then
                    upstream=${GIT_SVN_ID:-git-svn};
                else
                    upstream=${svn_upstream#/};
                fi;
            else
                if [[ "svn+git" = "$upstream" ]]; then
                    upstream="@{upstream}";
                fi;
            fi
        ;;
    esac;
    if [[ -z "$legacy" ]]; then
        count="$(git rev-list --count --left-right 				"$upstream"...HEAD 2>/dev/null)";
    else
        local commits;
        if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"; then
            local commit behind=0 ahead=0;
            for commit in $commits;
            do
                case "$commit" in 
                    "<"*)
                        ((behind++))
                    ;;
                    *)
                        ((ahead++))
                    ;;
                esac;
            done;
            count="$behind	$ahead";
        else
            count="";
        fi;
    fi;
    if [[ -z "$verbose" ]]; then
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p="="
            ;;
            "0	"*)
                p=">"
            ;;
            *"	0")
                p="<"
            ;;
            *)
                p="<>"
            ;;
        esac;
    else
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p=" u="
            ;;
            "0	"*)
                p=" u+${count#0	}"
            ;;
            *"	0")
                p=" u-${count%	0}"
            ;;
            *)
                p=" u+${count#*	}-${count%	*}"
            ;;
        esac;
        if [[ -n "$count" && -n "$name" ]]; then
            __git_ps1_upstream_name=$(git rev-parse 				--abbrev-ref "$upstream" 2>/dev/null);
            if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then
                p="$p \${__git_ps1_upstream_name}";
            else
                p="$p ${__git_ps1_upstream_name}";
                unset __git_ps1_upstream_name;
            fi;
        fi;
    fi
}
__grub_dir () 
{ 
    local i c=1 boot_dir;
    for ((c=1; c <= ${#COMP_WORDS[@]}; c++ ))
    do
        i="${COMP_WORDS[c]}";
        case "$i" in 
            --boot-directory)
                c=$((++c));
                i="${COMP_WORDS[c]}";
                boot_dir="${i##*=}";
                break
            ;;
        esac;
    done;
    boot_dir=${boot_dir-/boot};
    echo "${boot_dir%/}/grub"
}
__grub_get_last_option () 
{ 
    local i;
    for ((i=$COMP_CWORD-1; i > 0; i-- ))
    do
        if [[ "${COMP_WORDS[i]}" == -* ]]; then
            echo "${COMP_WORDS[i]}";
            break;
        fi;
    done
}
__grub_get_options_from_help () 
{ 
    local prog;
    if [ $# -ge 1 ]; then
        prog="$1";
    else
        prog="${COMP_WORDS[0]}";
    fi;
    local i IFS=" "'	''
';
    for i in $(LC_ALL=C $prog --help);
    do
        case $i in 
            --*)
                echo "${i%=*}"
            ;;
        esac;
    done
}
__grub_get_options_from_usage () 
{ 
    local prog;
    if [ $# -ge 1 ]; then
        prog="$1";
    else
        prog="${COMP_WORDS[0]}";
    fi;
    local i IFS=" "'	''
';
    for i in $(LC_ALL=C $prog --usage);
    do
        case $i in 
            \[--*\])
                i=${i#[};
                echo ${i%%?(=*)]}
            ;;
        esac;
    done
}
__grub_list_menuentries () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local config_file=$(__grub_dir)/grub.cfg;
    if [ -f "$config_file" ]; then
        local IFS='
';
        COMPREPLY=($(compgen             -W "$( awk -F "[\"']" '/menuentry/ { print $2 }' $config_file )"             -- "$cur" ));
    fi
}
__grub_list_modules () 
{ 
    local grub_dir=$(__grub_dir);
    local IFS='
';
    COMPREPLY=($( compgen -f -X '!*/*.mod' -- "${grub_dir}/$cur" | {
         while read -r tmp; do
             [ -n $tmp ] && {
                 tmp=${tmp##*/}
                 printf '%s\n' ${tmp%.mod}
             }
         done
         }
        ))
}
__grubcomp () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    if [ $# -gt 2 ]; then
        cur="$3";
    fi;
    case "$cur" in 
        --*=)
            COMPREPLY=()
        ;;
        *)
            local IFS=' ''	''
';
            COMPREPLY=($(compgen -P "${2-}" -W "${1-}" -S "${4-}" -- "$cur"))
        ;;
    esac
}
__loaded_modules () 
{ 
    while IFS='	' read idx name _; do
        printf "%s %s\n" "$idx" "$name";
    done < <(pactl list modules short 2> /dev/null)
}
__ltrim_colon_completions () 
{ 
    if [[ "$1" == *:* && "$COMP_WORDBREAKS" == *:* ]]; then
        local colon_word=${1%"${1##*:}"};
        local i=${#COMPREPLY[*]};
        while [[ $((--i)) -ge 0 ]]; do
            COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
        done;
    fi
}
__parse_options () 
{ 
    local option option2 i IFS=' 	
,/|';
    option=;
    for i in $1;
    do
        case $i in 
            ---*)
                break
            ;;
            --?*)
                option=$i;
                break
            ;;
            -?*)
                [[ -n $option ]] || option=$i
            ;;
            *)
                break
            ;;
        esac;
    done;
    [[ -n $option ]] || return 0;
    IFS=' 	
';
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
        option2=${option/"${BASH_REMATCH[1]}"/};
        option2=${option2%%[<{().[]*};
        printf '%s\n' "${option2/=*/=}";
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"};
    fi;
    option=${option%%[<{().[]*};
    printf '%s\n' "${option/=*/=}"
}
__ports () 
{ 
    pactl list cards 2> /dev/null | awk -e '/^\tPorts:/ {
            flag=1; next
         }

         /^\t[A-Za-z]/ {
             flag=0
         }

         flag {
             if (/^\t\t[A-Za-z]/)
                 ports = ports substr($0, 3, index($0, ":")-3) " "
         }

         END {
             print ports
         }'
}
__profiles () 
{ 
    pactl list cards 2> /dev/null | awk -e '/^\tProfiles:/ {
            flag=1; next
        }

        /^\t[A-Za-z]/ {
            flag=0
        }

        flag {
            if (/^\t\t[A-Za-z]/)
                profiles = profiles substr($0, 3, index($0, ": ")-3) " "
        }

        END {
            print profiles
        }'
}
__reassemble_comp_words_by_ref () 
{ 
    local exclude i j line ref;
    if [[ -n $1 ]]; then
        exclude="${1//[^$COMP_WORDBREAKS]}";
    fi;
    eval $3=$COMP_CWORD;
    if [[ -n $exclude ]]; then
        line=$COMP_LINE;
        for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && ${COMP_WORDS[$i]} == +([$exclude]) ]]; do
                [[ $line != [' 	']* ]] && (( j >= 2 )) && ((j--));
                ref="$2[$j]";
                eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
                [[ $i == $COMP_CWORD ]] && eval $3=$j;
                line=${line#*"${COMP_WORDS[$i]}"};
                [[ $line == [' 	']* ]] && ((j++));
                (( $i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2;
            done;
            ref="$2[$j]";
            eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
            line=${line#*"${COMP_WORDS[i]}"};
            [[ $i == $COMP_CWORD ]] && eval $3=$j;
        done;
        [[ $i == $COMP_CWORD ]] && eval $3=$j;
    else
        eval $2=\( \"\${COMP_WORDS[@]}\" \);
    fi
}
__resample_methods () 
{ 
    while read name; do
        printf "%s\n" "$name";
    done < <(pulseaudio --dump-resample-methods 2> /dev/null)
}
__sink_inputs () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list sink-inputs short 2> /dev/null)
}
__sinks () 
{ 
    while IFS='	' read _ name _ _ _; do
        printf "%s\n" "$name";
    done < <(pactl list sinks short 2> /dev/null)
}
__sinks_idx () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list sinks short 2> /dev/null)
}
__source_outputs () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list source-outputs short 2> /dev/null)
}
__sources () 
{ 
    while IFS='	' read _ name _ _ _; do
        printf "%s\n" "$name";
    done < <(pactl list sources short 2> /dev/null)
}
__unfunc () 
{ 
    if [[ -z ${AX_FUNCS[$1]} ]]; then
        if isfunc $1; then
            echo "$1 is a function, not a func!";
            echo "hint: use unset -f to delete functions.";
        else
            echo "$1: unknown func name";
        fi;
        false;
    else
        if rm "${AX_FUNCS[$1]}" || [[ ! -f ${AX_FUNCS[$1]} ]]; then
            unset -f $1;
            unset AX_FUNCS[$1];
            echo "func $1 deleted";
            true;
        else
            echo "failed to delete $1, check your permissions of ${AX_FUNCS[$1]} and try again";
            echo "$1 will not be removed from memory unless you are allowed to delete the file.";
            echo "hint: You may delete the file yourself, and then re-run this command to force a delete.";
            false;
        fi;
    fi
}
_adb () 
{ 
    local cur prev opts;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    opts="shell push pull reboot reboot-bootloader forward logcat devices kill-server root remount";
    case "$prev" in 
        shell | pull | reboot-bootloader | logcat | devices | kill-server | root | remount)
            COMPREPLY=();
            return 0
        ;;
        reboot)
            COMPREPLY=($(compgen -W "bootloader recovery" -- $cur));
            return 0
        ;;
        push)
            COMPREPLY=($(compgen -o default -o plusdirs -f -- $cur));
            return 0
        ;;
        *)
            local prev2="${COMP_WORDS[COMP_CWORD-2]}";
            if [ "$prev2" == "push" ] || [ "$prev2" == "reboot" ]; then
                return 0;
            fi
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts" -- $cur));
    return 0
}
_allowed_groups () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -g -- "$1" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -Gn 2>/dev/null || groups 2>/dev/null )" -- "$1" ));
    fi
}
_allowed_users () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -u -- "${1:-$cur}" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -un 2>/dev/null || whoami 2>/dev/null )" -- "${1:-$cur}" ));
    fi
}
_apport-bug () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help --save -v --version --tag -w --window';
    case "$prev" in 
        ubuntu-bug | apport-bug)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions="--tag";
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
_apport-cli () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help -f --file-bug -u --update-bug -s --symptom \
                 -c --crash-file --save -v --version --tag -w --window';
    case "$prev" in 
        apport-cli)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        -f | --file-bug)
            param="-P --pid -p --package -s --symptom";
            COMPREPLY=($( compgen -W "$param $(_apport_symptoms)" -- $cur))
        ;;
        -s | --symptom)
            COMPREPLY=($( compgen -W "$(_apport_symptoms)" -- $cur))
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -c | --crash-file)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions='--tag';
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--symptom.* || "${COMP_WORDS[*]}" =~ .*\ -s\ .* ]]; then
                dashoptions="-s --symptom $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--update.* || "${COMP_WORDS[*]}" =~ .*\ -u\ .* ]]; then
                dashoptions="-u --update $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--file-bug.* || "${COMP_WORDS[*]}" =~ .*\ -f\ .* ]]; then
                dashoptions="-f --file-bug $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--crash-file.* || "${COMP_WORDS[*]}" =~ .*\ -c\ .* ]]; then
                dashoptions="-c --crash-file $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
_apport-collect () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-collect)
            COMPREPLY=($( compgen -W "-p --package --tag" -- $cur))
        ;;
        -p | --package)
            COMPREPLY=($( apt-cache pkgnames $cur 2> /dev/null ))
        ;;
        --tag)
            return 0
        ;;
        *)
            if [[ "${COMP_WORDS[*]}" =~ .*\ -p.* || "${COMP_WORDS[*]}" =~ .*--package.* ]]; then
                COMPREPLY=($( compgen -W "--tag" -- $cur));
            else
                COMPREPLY=($( compgen -W "-p --package --tag" -- $cur));
            fi
        ;;
    esac
}
_apport-unpack () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-unpack)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
    esac
}
_apport_parameterless () 
{ 
    local param;
    param="$dashoptions            $( apt-cache pkgnames $cur 2> /dev/null )            $( command ps axo pid | sed 1d )            $( _apport_symptoms )            $( compgen -G "${cur}*" )";
    COMPREPLY=($( compgen -W "$param" -- $cur))
}
_apport_symptoms () 
{ 
    local syms;
    if [ -r /usr/share/apport/symptoms ]; then
        for FILE in $(ls /usr/share/apport/symptoms);
        do
            if [[ ! "$FILE" =~ ^_.* && -n $(egrep "^def run\s*\(.*\):" /usr/share/apport/symptoms/$FILE) ]]; then
                syms="$syms ${FILE%.py}";
            fi;
        done;
    fi;
    echo $syms
}
_available_interfaces () 
{ 
    local cmd PATH=$PATH:/sbin;
    if [[ ${1:-} == -w ]]; then
        cmd="iwconfig";
    else
        if [[ ${1:-} == -a ]]; then
            cmd="{ ifconfig || ip link show up; }";
        else
            cmd="{ ifconfig -a || ip link show; }";
        fi;
    fi;
    COMPREPLY=($( eval $cmd 2>/dev/null | awk         '/^[^ \t]/ { if ($1 ~ /^[0-9]+:/) { print $2 } else { print $1 } }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur" ))
}
_ax__generate_values () 
{ 
    eval "${PROCS[${STEPS[$2]}]}" > "$1" && (($2==$3)) && unset -f $FUNCNAME
}
_axi_cache () 
{ 
    local cur prev cmd;
    COMPREPLY=();
    type _get_comp_words_by_ref &> /dev/null && { 
        _get_comp_words_by_ref -n: cur prev
    } || { 
        cur=$(_get_cword ":");
        prev=${COMP_WORDS[$COMP_CWORD-1]}
    };
    cmd=${COMP_WORDS[1]};
    case "$prev" in 
        *axi-cache*)
            COMPREPLY=($(compgen -W "help more search show again showpkg showsrc depends rdepends policy madison" -- "$cur"));
            return 0
        ;;
        --sort)
            COMPREPLY=($(compgen -W "$(egrep ^[a-z] /var/lib/apt-xapian-index/values | awk -F"\t" '{print $1}')" -- "$cur"));
            return 0
        ;;
    esac;
    case "$cmd" in 
        search | again)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($(compgen -W "--sort --tags" -- "$cur"));
                return 0;
            fi
        ;;
        show | showpkg | showsrc | depends | rdepends | policy | madison)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($(compgen -W "--last" -- "$cur"));
                return 0;
            fi
        ;;
        *)
            return 0
        ;;
    esac;
    if [ -n "$cur" ]; then
        COMPREPLY=($(compgen -W "$(${COMP_WORDS[@]} --tabcomplete=partial)" -- "$cur"));
    else
        COMPREPLY=($(compgen -W "$(${COMP_WORDS[@]} --tabcomplete=plain)" -- "$cur"));
    fi;
    return 0
}
_b_commit () 
{ 
    echo -ne "Committing...";
    builtin alias > ~/.bash_aliases;
    builtin bind -v > ~/.inputrc;
    builtin bind -s >> ~/.inputrc;
    builtin bind -p >> ~/.inputrc;
    echo "done!"
}
_b_edit_glo () 
{ 
    [[ ! -v $EDITOR ]] && EDITOR=vim;
    if [[ $UID -ne 0 ]]; then
        if sudo -l $EDITOR &> /dev/null; then
            sudo $EDITOR /etc/bash.bashrc;
        else
            echo "sudo access denied, read only privs...";
            $EDITOR /etc/bash.bashrc;
        fi;
    else
        $EDITOR /etc/bash.bashrc;
    fi
}
_b_edit_loc () 
{ 
    [[ ! -v $EDITOR ]] && EDITOR=vim;
    $EDITOR ~/.bashrc
}
_b_flushme () 
{ 
    if ax.config.has disable_flush_longlines && [[ $(ax.config disable_flush_longlines) == true ]]; then
        true debug echo "nb: long-line flushout is disabled at this time.";
    else
        eval "for i in {0..$((LINES*COLUMNS))}; do echo; done";
    fi;
    echo -e "\n\n**** Starting a New Session ****\n";
    exec "$SHELL"
}
_b_perltoggle () 
{ 
    if [[ $1 == SETUP ]] && [[ ! -v PERLMODEPATH && ! -v PERLLIBPATH ]]; then
        true debug echo "Setting Defaults for Perl Modes (Just Two: AP On/Off)";
        true debug echo "Set your own by creating an array of PERLMODEPATHs and PERLLIBPATHs";
        if ax.config.has perl_mode_paths; then
            eval declare -ga PERLMODEPATH=(`ax.config perl_mode_paths`);
            eval declare -ga PERLMODELIB=(`ax.config perl_mode_libs`);
        fi;
        if [[ ${#PERLMODEPATH[@]} -lt 2 ]] || [[ ${#PERLMODELIB[@]} -lt 2 ]]; then
            declare -ga PERLMODEPATH=("$PATH" "/opt/activeperl/bin:$PATH");
            declare -ga PERLMODELIB=("" "/opt/activeperl/lib");
            PERLTOGGLEMODE="(${#PERLMODEPATH[@]} alternatives configured!)";
        else
            PERLTOGGLEMODE="(unconfigured sample settings mode)";
        fi;
        if [[ $1 == SETUP ]]; then
            ACTIVEPERL_MODE=${#PERLMODEPATH[@]};
            _b_perltoggle SETUP_MSG;
            return;
        fi;
    else
        if [[ $1 == SETUP ]]; then
            echo "PERLTOGGLE: already set up";
            return;
        fi;
    fi;
    local -a MODES=('[32;1mSystem (Perl 5.18.2)[0m' '[35;1mActivePerl+Perl 5.20.1[0m');
    [[ -v ACTIVEPERL_MODE ]] || declare -gi ACTIVEPERL_MODE;
    let ACTIVEPERL_MODE++;
    if [[ $ACTIVEPERL_MODE -ge ${#PERLMODEPATH[@]} ]]; then
        ACTIVEPERL_MODE=0;
    fi;
    if [[ $1 == SETUP_MSG ]]; then
        echo "* Perl Mode Switcher Created (Starting with ${MODES[$ACTIVEPERL_MODE]})";
    else
        echo "Perl Mode Now: ${MODES[$ACTIVEPERL_MODE]}";
    fi;
    export PATH="${PERLMODEPATH[$ACTIVEPERL_MODE]}";
    export PERL5LIB="${PERLMODELIB[$ACTIVEPERL_MODE]}";
    if [[ -z $PERL5LIB ]]; then
        unset PERL5LIB;
    fi
}
_b_poweroff () 
{ 
    echo -e "\n\n*** Powering Down ***\n\n";
    echo "sending other processing the term signal, logging off, harmfully... (in 2 seconds) [X=abort]";
    export TMOUT=2;
    read -sn 1;
    export TMOUT=0;
    if [[ ${REPLY,,} == x ]]; then
        echo "ABORT";
    else
        if sudo pm-hibernate; then
            echo "Returning from hibernation...ok";
        else
            echo "Hibernation failed, doing a true power-off...";
            exec shutdown -P now;
            echo -e "$bad";
        fi;
    fi
}
_b_reresource () 
{ 
    echo -ne "Re-Resourcing...";
    echo "setting defaults...";
    set +o nounset;
    shopt -s progcomp;
    shopt -u nullglob;
    unset IFS;
    echo -ne "completion...";
    source /etc/bash_completion;
    source /usr/share/bash-completion/bash_completion;
    echo -ne "completion loaders...";
    for i in /usr/share/bash-completion/completions/*;
    do
        echo -ne "[2K[scompletion loaders...$i[u";
        . "$i";
    done;
    echo -ne "completion loaders... bindings";
    bind '"	": complete';
    echo -ne "finished."
}
_b_showhlp_page () 
{ 
    if [[ $1 == SETUP ]]; then
        _detect_terminal;
        _setup_bvars;
        _reload_bindings;
        _reload_bindings_f1;
    fi;
    echo "* Keyboard Bindings and Display Help (F1=Help F2=Readline Bindings)"
}
_b_showhlp_page_text () 
{ 
    echo "---------------------------------------------------------------";
    echo " Press Ctrl+N To Reload Completions/Aliases Any Time";
    echo " Press Ctrl+O To Output Aliases/Completions to Cache";
    echo " Press Ctrl+D To Logout";
    echo " Press Ctrl+F To Flush Session Changes";
    echo " Press Ctrl+E To Exit System and Power Down";
    echo " Press Ctrl+L To Clear The Screen";
    echo " Press Ctrl+K For A Compact Directory Listing";
    echo " Press Alt+Up To Go Up One Directory Branch";
    echo " Press Ctrl+P To Change Perl Mode";
    echo " Press F1 To Show This Page Again and Reload Bindings";
    echo "---------------------------------------------------------------";
    echo "Press $GLOF2 To Edit Global Bash Startup (/etc/bash.bashrc)";
    echo "Press $LOCF2 To Edit Local Bash Startup (~/bash.bashrc)";
    echo "---------------------------------------------------------------"
}
_b_showkeyhelp_page_ () 
{ 
    echo -ne "[0;44m";
    bind -p | grep --color=auto -P 'self-insert|backward-ch|lowercase-ver|not bound|[a-z]-insert' -v | sed -r 's/\\\C/Ctrl/g;s/\\e/Esc-/g' | tr '"' ' ' | sed -r 's/(\S)(Ctrl|Esc)/\1,\2/g' | sed -r 's/(Ctrl|Esc)(-)(\s|,)/\1\3/g' | awk ' { printf "[1m%-20s[0;44m\t%s\n",$1,$3}; ' | column -c $COLUMNS | sed -r 's/-/[1;30m-[0;44m/g'
}
_bzr_lazy () 
{ 
    unset _bzr;
    eval "$(bzr bash-completion)";
    if [[ $(type -t _bzr) == function ]]; then
        unset _bzr_lazy;
        _bzr;
        return $?;
    else
        return 1;
    fi
}
_cd () 
{ 
    local cur prev words cword;
    _init_completion || return;
    local IFS='
' i j k;
    compopt -o filenames;
    if [[ -z "${CDPATH:-}" || "$cur" == ?(.)?(.)/* ]]; then
        _filedir -d;
        return 0;
    fi;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    for i in ${CDPATH//:/'
'};
    do
        k="${#COMPREPLY[@]}";
        for j in $( compgen -d $i/$cur );
        do
            if [[ ( -n $mark_symdirs && -h $j || -n $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
                j+="/";
            fi;
            COMPREPLY[k++]=${j#$i/};
        done;
    done;
    _filedir -d;
    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
        i=${COMPREPLY[0]};
        if [[ "$i" == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi;
    return 0
}
_cd_devices () 
{ 
    COMPREPLY+=($( compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}" ))
}
_cmake () 
{ 
    local cur prev words cword split=false;
    _init_completion -n := || return;
    local prefix=;
    if [[ $cur == -D* ]]; then
        prev=-D;
        prefix=-D;
        cur="${cur#-D}";
    else
        if [[ $cur == -U* ]]; then
            prev=-U;
            prefix=-U;
            cur="${cur#-U}";
        fi;
    fi;
    case "$prev" in 
        -D)
            if [[ $cur == *=* ]]; then
                local var type value;
                var="${cur%%[:=]*}";
                value="${cur#*=}";
                if [[ $cur == CMAKE_BUILD_TYPE* ]]; then
                    COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                        MinSizeRel' -- "$value" ));
                    return;
                fi;
                if [[ $cur == *:* ]]; then
                    type="${cur#*:}";
                    type="${type%%=*}";
                else
                    type=$( cmake -LA -N 2>/dev/null | grep "$var:"                         2>/dev/null );
                    type="${type#*:}";
                    type="${type%%=*}";
                fi;
                case "$type" in 
                    FILEPATH)
                        cur="$value";
                        _filedir;
                        return
                    ;;
                    PATH)
                        cur="$value";
                        _filedir -d;
                        return
                    ;;
                    BOOL)
                        COMPREPLY=($( compgen -W 'ON OFF TRUE FALSE' --                             "$value" ));
                        return
                    ;;
                    STRING | INTERNAL)
                        return
                    ;;
                esac;
            else
                if [[ $cur == *:* ]]; then
                    local type="${cur#*:}";
                    COMPREPLY=($( compgen -W 'FILEPATH PATH STRING BOOL INTERNAL'                    -S = -- "$type" ));
                    compopt -o nospace;
                else
                    COMPREPLY=($( compgen -W '$( cmake -LA -N | tail -n +2 |
                    cut -f1 -d: )' -P "$prefix" -- "$cur" ));
                    compopt -o nospace;
                fi;
            fi;
            return
        ;;
        -U)
            COMPREPLY=($( compgen -W '$( cmake -LA -N | tail -n +2 |
                cut -f1 -d: )' -P "$prefix" -- "$cur" ));
            return
        ;;
    esac;
    _split_longopt && split=true;
    case "$prev" in 
        -C | -P | --graphviz | --system-information)
            _filedir;
            return
        ;;
        --build)
            _filedir -d;
            return
        ;;
        -E)
            COMPREPLY=($( compgen -W "$( cmake -E help |& sed -n                 '/^  /{s|^  \([^ ]\{1,\}\) .*$|\1|;p}' 2>/dev/null )"                 -- "$cur" ));
            return
        ;;
        -G)
            local IFS='
';
            local quoted;
            printf -v quoted %q "$cur";
            COMPREPLY=($( compgen -W '$( cmake --help 2>/dev/null | sed -n \
                -e "1,/^Generators/d" \
                -e "/^  *[^ =]/{s|^ *\([^=]*[^ =]\).*$|\1|;s| |\\\\ |g;p}" \
                2>/dev/null )' -- "$quoted" ));
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( cmake --help-command-list 2>/dev/null|
                grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-module)
            COMPREPLY=($( compgen -W '$( cmake --help-module-list 2>/dev/null|
                grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-policy)
            COMPREPLY=($( compgen -W '$( cmake --help-policies 2>/dev/null |
                grep "^  CMP" 2>/dev/null )' -- "$cur" ));
            return
        ;;
        --help-property)
            COMPREPLY=($( compgen -W '$( cmake --help-property-list \
                2>/dev/null | grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-variable)
            COMPREPLY=($( compgen -W '$( cmake --help-variable-list \
                2>/dev/null | grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
    esac;
    $split && return;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_command () 
{ 
    local offset i;
    offset=1;
    for ((i=1; i <= COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _command_offset $offset
}
_command_offset () 
{ 
    local word_offset=$1 i j;
    for ((i=0; i < $word_offset; i++ ))
    do
        for ((j=0; j <= ${#COMP_LINE}; j++ ))
        do
            [[ "$COMP_LINE" == "${COMP_WORDS[i]}"* ]] && break;
            COMP_LINE=${COMP_LINE:1};
            ((COMP_POINT--));
        done;
        COMP_LINE=${COMP_LINE#"${COMP_WORDS[i]}"};
        ((COMP_POINT-=${#COMP_WORDS[i]}));
    done;
    for ((i=0; i <= COMP_CWORD - $word_offset; i++ ))
    do
        COMP_WORDS[i]=${COMP_WORDS[i+$word_offset]};
    done;
    for ((i; i <= COMP_CWORD; i++ ))
    do
        unset COMP_WORDS[i];
    done;
    ((COMP_CWORD -= $word_offset));
    COMPREPLY=();
    local cur;
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 0 ]]; then
        local IFS='
';
        compopt -o filenames;
        COMPREPLY=($( compgen -d -c -- "$cur" ));
    else
        local cmd=${COMP_WORDS[0]} compcmd=${COMP_WORDS[0]};
        local cspec=$( complete -p $cmd 2>/dev/null );
        if [[ ! -n $cspec && $cmd == */* ]]; then
            cspec=$( complete -p ${cmd##*/} 2>/dev/null );
            [[ -n $cspec ]] && compcmd=${cmd##*/};
        fi;
        if [[ ! -n $cspec ]]; then
            compcmd=${cmd##*/};
            _completion_loader $compcmd;
            cspec=$( complete -p $compcmd 2>/dev/null );
        fi;
        if [[ -n $cspec ]]; then
            if [[ ${cspec#* -F } != $cspec ]]; then
                local func=${cspec#*-F };
                func=${func%% *};
                if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}" "${COMP_WORDS[${#COMP_WORDS[@]}-2]}";
                else
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}";
                fi;
                local opt;
                while [[ $cspec == *" -o "* ]]; do
                    cspec=${cspec#*-o };
                    opt=${cspec%% *};
                    compopt -o $opt;
                    cspec=${cspec#$opt};
                done;
            else
                cspec=${cspec#complete};
                cspec=${cspec%%$compcmd};
                COMPREPLY=($( eval compgen "$cspec" -- '$cur' ));
            fi;
        else
            if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
                _minimal;
            fi;
        fi;
    fi
}
_compbind.ax_POSTLOAD () 
{ 
    ax.echo "$AX_DESCRIPTION{$(basename $BASH_SOURCE)}: $FUNCNAME.$LINENO: loaded";
    eval "${FUNCNAME}_stub \"\$@\""
}
_compbind.ax_POSTLOAD_stub () 
{ 
    :
}
_compbind.ax_PRELOAD () 
{ 
    ax.echo "$AX_DESCRIPTION{$(basename $BASH_SOURCE)}: $FUNCNAME.$LINENO: loading";
    eval "${FUNCNAME}_stub \"\$@\""
}
_compbind.ax_PRELOAD_stub () 
{ 
    :
}
_compbind.ax_REMOVE () 
{ 
    ax.echo "$AX_DESCRIPTION{$(basename $BASH_SOURCE)}: $FUNCNAME.$LINENO: removed";
    eval "${FUNCNAME}_stub \"\$@\""
}
_compbind.ax_REMOVE_stub () 
{ 
    :
}
_complete_as_root () 
{ 
    [[ $EUID -eq 0 || -n ${root_command:-} ]]
}
_complete_vim_addons () 
{ 
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    commands="list status install remove disable amend files show";
    any_command=$(echo $commands | sed -e 's/\s\+/|/g');
    options="-h --help -r --registry-dir -s --source-dir -t --target-dir -v --verbose -y --system-dir -w --system-wide -q --query";
    any_option=$(echo $options | sed -e 's/\s\+/|/g');
    if [[ "$prev" == 'vim-addons' ]] || [[ "$prev" == 'vim-addon-manager' ]] || [[ "$prev" == 'vam' ]]; then
        COMPREPLY=($( compgen -W "$commands" -- $cur ));
        return 0;
    fi;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$options" -- $cur));
        return 0;
    fi;
    if [[ "$prev" == @(-r|--registry-dir|-s|--source-dir|-t|--target-dir|-y|--system-dir) ]]; then
        COMPREPLY=($( compgen -o dirnames -- $cur ));
        return 0;
    fi;
    command='';
    target_dir='';
    system_wide='';
    system_dir='';
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++))
    do
        if [[ ${COMP_WORDS[i]} == @($any_command) ]]; then
            command=${COMP_WORDS[i]};
        fi;
        if [[ ${COMP_WORDS[i]} == @(-w|--system-wide) ]]; then
            system_wide="--system-wide";
        fi;
        if [[ $i -gt 0 ]]; then
            if [[ ${COMP_WORDS[i-1]} == @(-t|--target-dir) ]]; then
                target_dir="--target-dir ${COMP_WORDS[i]}";
            fi;
            if [[ ${COMP_WORDS[i-1]} == @(-y|--system-dir) ]]; then
                system_dir="--system-dir ${COMP_WORDS[i]}";
            fi;
        fi;
    done;
    query="vim-addons status --query $system_wide $system_dir $target_dir";
    if [[ -z "$command" ]]; then
        COMPREPLY=();
        return 0;
    fi;
    case "$command" in 
        list)
            COMPREPLY=()
        ;;
        install)
            COMPREPLY=($(  $query | grep -e "^$cur" | grep -v -e "installed$" | sed -e 's/^\(\S\+\).*/\1/' ))
        ;;
        remove | disable | amend)
            COMPREPLY=($(  $query | grep -e "^$cur" | grep -e "installed$" | sed -e 's/^\(\S\+\).*/\1/' ))
        ;;
        *)
            COMPREPLY=($(grep -h "^addon: $cur" /usr/share/vim/registry/*.yaml | sed -e 's/^addon:\s*//'))
        ;;
    esac
}
_completion_loader () 
{ 
    local compfile=./completions;
    [[ $BASH_SOURCE == */* ]] && compfile="${BASH_SOURCE%/*}/completions";
    compfile+="/${1##*/}";
    [[ -f "$compfile" ]] && . "$compfile" &> /dev/null && return 124;
    complete -F _minimal "$1" && return 124
}
_configured_interfaces () 
{ 
    if [[ -f /etc/debian_version ]]; then
        COMPREPLY=($( compgen -W "$( sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p'            /etc/network/interfaces )" -- "$cur" ));
    else
        if [[ -f /etc/SuSE-release ]]; then
            COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
        else
            if [[ -f /etc/pld-release ]]; then
                COMPREPLY=($( compgen -W "$( command ls -B             /etc/sysconfig/interfaces |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            else
                COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network-scripts/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            fi;
        fi;
    fi
}
_count_args () 
{ 
    local i cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    args=1;
    for i in "${words[@]:1:cword-1}";
    do
        [[ "$i" != -* ]] && args=$(($args+1));
    done
}
_cpack () 
{ 
    local cur prev words cword;
    _init_completion -n = || return;
    case "$prev" in 
        -G)
            COMPREPLY=($( compgen -W '$( cpack --help 2>/dev/null |
                sed -e "1,/^Generators/d" -e "s|^ *\([^ ]*\) .*$|\1|" \
                2>/dev/null )' -- "$cur" ));
            return
        ;;
        -C)
            COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                MinSizeRel' -- "$cur" ));
            return
        ;;
        -D)
            [[ $cur == *=* ]] && return;
            COMPREPLY=($( compgen -W '$( cpack --help-variable-list \
                2>/dev/null | grep -v "^cpack version " )' -S = -- "$cur" ));
            compopt -o nospace;
            return
        ;;
        -P | -R | --vendor)
            return
        ;;
        -B)
            _filedir -d;
            return
        ;;
        --config)
            _filedir;
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( cpack --help-command-list 2>/dev/null|
                grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
        --help-variable)
            COMPREPLY=($( compgen -W '$( cpack --help-variable-list \
                2>/dev/null | grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_cryptdisks () 
{ 
    local tf;
    tf=${TABFILE-"/etc/crypttab"};
    COMPREPLY=($(egrep -v "^[[:space:]]*(#|$)" "${tf}" | egrep -o "^${COMP_WORDS[COMP_CWORD]}[^[:space:]]*"));
    return 0
}
_ctest () 
{ 
    local cur prev words cword;
    _init_completion -n = || return;
    case "$prev" in 
        -C | --build-config)
            COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                MinSizeRel' -- "$cur" ));
            return
        ;;
        -j | --parallel)
            COMPREPLY=($( compgen -W "{1..$(( $(_ncpus)*2 ))}" -- "$cur" ));
            return
        ;;
        -O | --output-log | -A | --add-notes | --extra-submit)
            _filedir;
            return
        ;;
        -L | --label-regex | -LE | --label-exclude)
            COMPREPLY=($( compgen -W '$( ctest --print-labels 2>/dev/null |
                grep "^  " 2>/dev/null | cut -d" " -f 3 )' -- "$cur" ));
            return
        ;;
        --track | -I | --tests-information | --max-width | --timeout | --stop-time)
            return
        ;;
        -R | --tests-regex | -E | --exclude-regex)
            COMPREPLY=($( compgen -W '$( ctest -N 2>/dev/null |
                grep "^  Test" 2>/dev/null | cut -d: -f 2 )' -- "$cur" ));
            return
        ;;
        -D | --dashboard)
            if [[ $cur == @(Experimental|Nightly|Continuous)* ]]; then
                local model action;
                action=${cur#@(Experimental|Nightly|Continuous)};
                model=${cur%"$action"};
                COMPREPLY=($( compgen -W 'Start Update Configure Build Test
                    Coverage Submit MemCheck' -P "$model" -- "$action" ));
            else
                COMPREPLY=($( compgen -W 'Experimental Nightly Continuous'                 -- "$cur" ));
                compopt -o nospace;
            fi;
            return
        ;;
        -M | --test-model)
            COMPREPLY=($( compgen -W 'Experimental Nightly Continuous' --                 "$cur" ));
            return
        ;;
        -T | --test-action)
            COMPREPLY=($( compgen -W 'Start Update Configure Build Test
                Coverage Submit MemCheck' -- "$cur" ));
            return
        ;;
        -S | --script | -SP | --script-new-process)
            _filedir '@(cmake|ctest)';
            return
        ;;
        --interactive-debug-mode)
            COMPREPLY=($( compgen -W '0 1' -- "$cur" ));
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( ctest --help-command-list 2>/dev/null|
                grep -v "^ctest version " )' -- "$cur" ));
            return
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_ctrl_a_add () 
{ 
    [[ ! -v BASH_CA_HANDLERS ]] && declare -ga BASH_CA_HANDLERS;
    BASH_CA_HANDLERS+=("$@")
}
_ctrl_a_del () 
{ 
    case $# in 
        0)
            echo "usage: $FUNCNAME [handler|index] ...";
            return 1
        ;;
    esac;
    if [[ ! -v BASH_CA_HANDLERS ]]; then
        declare -ga BASH_CA_HANDLERS;
    else
        declare -n b=BASH_CA_HANDLERS;
        declare -ga NEW_BCH=();
        declare -i i=0;
        declare -i max=${#b[@]};
        NEEDSMOD=0;
        for ((i=0; i<max; i++))
        do
            for j in "$@";
            do
                if [[ $j != $i ]] && [[ $j != "${b[i]}" ]]; then
                    NEW_BCH+=("${b[i]}");
                else
                    echo "removed $j (index=$i, data=${b[i]}) from handlers!";
                    NEEDSMOD=1;
                fi;
            done;
        done;
        case $NEEDSMOD in 
            1)
                BASH_CA_HANDLERS=("${NEW_BCH[@]}")
            ;;
            0)
                echo "Error: none found ($*)"
            ;;
        esac;
    fi
}
_ctrl_a_handler () 
{ 
    if [[ -v BASH_CA_HANDLERS ]]; then
        for i in "${BASH_CA_HANDLERS[@]}";
        do
            $i "$@";
        done;
    else
        echo "No Hook (CTRL+A) Handlers Installed, Install One First";
    fi
}
_debconf_show () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    COMPREPLY=($( compgen -W '--listowners --listdbs --db=' -- $cur ) $( apt-cache pkgnames -- $cur ))
}
_desktop_file_validate () 
{ 
    COMPRELY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _filedir '@(desktop)'
}
_detect_terminal () 
{ 
    echo -n "* Terminal Detection ";
    if ax.config.has custom_terminal; then
        local NEWTERM="$(ax.config.get custom_terminal)";
        case $NEWTERM in 
            keep)
                echo "Left Untouched ($TERM)"
            ;;
            *)
                echo "Usera-Defined ($NEWTERM)";
                TERM="$NEWTERM"
            ;;
        esac;
    else
        if function _xprop2 () 
        { 
            unset -f _xprop2;
            command xprop $@ | grep --color=auto -vP '^(\s|\t|$|_NET_SUPPORTED|_NET_WM_ICON|_?QT|RESOURCE).*'
        };
        _xprop2 -root &> /dev/null; then
            TERM="xterm-256color";
        else
            case $(tty) in 
                */*tty*[0-9])
                    if [[ -L /vmlinuz ]]; then
                        TERM=linux;
                    else
                        TERM=cons25;
                    fi
                ;;
                *pts*)
                    TERM=ansi
                ;;
                *)
                    TERM=dumb
                ;;
            esac;
        fi;
        echo " [detected as $TERM]";
    fi
}
_dkms () 
{ 
    local cur prev command module i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "add autoinstall remove build install uninstall 			match mkdriverdisk mktarball ldtarball mkrpm mkdeb mkdsc mkkmp 			status" -- $cur ));
    else
        prev=${COMP_WORDS[COMP_CWORD-1]};
        command=${COMP_WORDS[1]};
        case $prev in 
            -m)
                if [ "$command" = 'add' ]; then
                    _filename_parts '.*-.*' 1;
                else
                    _subdirectories /var/lib/dkms;
                fi;
                return 0
            ;;
            -v)
                for ((i=1; i < COMP_CWORD; i++ ))
                do
                    if [[ "${COMP_WORDS[i]}" == -m ]]; then
                        module=${COMP_WORDS[i+1]};
                        break;
                    fi;
                done;
                if [ -n "$module" ]; then
                    if [ "$command" = 'add' ]; then
                        _filename_parts "$module-.*" 2;
                    else
                        _subdirectories /var/lib/dkms/$module;
                    fi;
                    return 0;
                fi
            ;;
            -k)
                _kernels;
                return 0
            ;;
            -@\(c | -spec | -archive | -config\))
                _filedir;
                return 0
            ;;
            --kernelsourcedir)
                _filedir -d;
                return 0
            ;;
        esac;
        if [[ "$cur" == -* ]]; then
            case $command in 
                add)
                    options='-c --rpm_safe_upgrade'
                ;;
                remove)
                    options='--rpm_safe_upgrade'
                ;;
                build)
                    options='--config'
                ;;
                mkdriverdisk)
                    options='-d --distro -r --release --size'
                ;;
                ldtarball)
                    options='--archive --force'
                ;;
                mktarball)
                    options='--source-only --binaries-only'
                ;;
                mkrpm)
                    options='--source-only'
                ;;
                mkkmp)
                    options='--spec'
                ;;
                match)
                    options='--templatekernel'
                ;;
            esac;
            options="$options -m -v -k -a --arch -q --quiet -V 				--version --all --no-prepare-kernel 				--no-clean-kernel --kernelsourcedir 				--directive";
            COMPREPLY=($( compgen -W "$options" -- $cur ));
        fi;
    fi
}
_dput () 
{ 
    local cur prev options paroptions special i delayed_options hosts;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    options='-c --config -d --debug -D --dinstall -f --force -h --help \
             -H --host-list -l --lintian -o --check-only -p --print \
             -P --passive -s --simulate -u --unchecked -e --delayed \
             -v --version -V --check-version';
    hosts=$(
	{
	    grep "^\[.*\]" $HOME/.dput.cf 2> /dev/null | tr -d [] || /bin/true
	    grep "^\[.*\]" /etc/dput.cf 2> /dev/null | tr -d [] || /bin/true
	} | grep -v '^DEFAULT$' | sort -u);
    paroptions="$options $hosts";
    case $prev in 
        --delayed | -e)
            delayed_options='0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15';
            COMPREPLY=($( compgen -W "$delayed_options" | grep ^$cur ))
        ;;
        --config | -c)
            COMPREPLY=($( compgen -o filenames -G "$cur*" ))
        ;;
        *)
            COMPREPLY=($(
		    compgen -G "${cur}*.changes"
		    compgen -G "${cur}*.asc"
		    compgen -G "${cur}*.sig"
		    compgen -W "$paroptions" | grep "^$cur"
		))
        ;;
    esac;
    return 0
}
_dvd_devices () 
{ 
    COMPREPLY+=($( compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}" ))
}
_expand () 
{ 
    if [[ "$cur" == \~*/* ]]; then
        eval cur=$cur 2> /dev/null;
    else
        if [[ "$cur" == \~* ]]; then
            cur=${cur#\~};
            COMPREPLY=($( compgen -P '~' -u "$cur" ));
            [[ ${#COMPREPLY[@]} -eq 1 ]] && eval COMPREPLY[0]=${COMPREPLY[0]};
            return ${#COMPREPLY[@]};
        fi;
    fi
}
_fastboot () 
{ 
    local cur prev opts;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    opts="reboot boot flash devices -w reboot-bootloader";
    case "$prev" in 
        reboot | devices | -w | reboot-bootloader)
            COMPREPLY=();
            return 0
        ;;
        flash)
            COMPREPLY=($(compgen -W "boot system recovery radio" -- $cur ));
            return 0
        ;;
        boot)
            COMPREPLY=($(compgen -o filenames -G "${cur}*.img"));
            return 0
        ;;
        *)
            local prev2="${COMP_WORDS[COMP_CWORD-2]}";
            local prev3="${COMP_WORDS[COMP_CWORD-3]}";
            if [ "$prev2" == "flash" ]; then
                COMPREPLY=($(compgen -o filenames -G "${cur}*.img"));
                return 0;
            else
                if [ "$prev2" == "boot" ]; then
                    COMPREPLY=();
                    return 0;
                else
                    if [ "$prev3" == "flash" ]; then
                        COMPREPLY=();
                        return 0;
                    fi;
                fi;
            fi
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts" -- $cur));
    return 0
}
_filedir () 
{ 
    local i IFS='
' xspec;
    _tilde "$cur" || return 0;
    local -a toks;
    local quoted x tmp;
    _quote_readline_by_ref "$cur" quoted;
    x=$( compgen -d -- "$quoted" ) && while read -r tmp; do
        toks+=("$tmp");
    done <<< "$x";
    if [[ "$1" != -d ]]; then
        xspec=${1:+"!*.@($1|${1^^})"};
        x=$( compgen -f -X "$xspec" -- $quoted ) && while read -r tmp; do
            toks+=("$tmp");
        done <<< "$x";
    fi;
    [[ -n ${COMP_FILEDIR_FALLBACK:-} && -n "$1" && "$1" != -d && ${#toks[@]} -lt 1 ]] && x=$( compgen -f -- $quoted ) && while read -r tmp; do
        toks+=("$tmp");
    done <<< "$x";
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames 2> /dev/null;
        COMPREPLY+=("${toks[@]}");
    fi
}
_filedir_xspec () 
{ 
    local cur prev words cword;
    _init_completion || return;
    _tilde "$cur" || return 0;
    local IFS='
' xspec=${_xspecs[${1##*/}]} tmp;
    local -a toks;
    toks=($(
        compgen -d -- "$(quote_readline "$cur")" | {
        while read -r tmp; do
            printf '%s\n' $tmp
        done
        }
        ));
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    xspec="$matchop($xspec|${xspec^^})";
    toks+=($(
        eval compgen -f -X "!$xspec" -- "\$(quote_readline "\$cur")" | {
        while read -r tmp; do
            [[ -n $tmp ]] && printf '%s\n' $tmp
        done
        }
        ));
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames;
        COMPREPLY=("${toks[@]}");
    fi
}
_filename_parts () 
{ 
    COMPREPLY=($( command ls -F /usr/src/ 2>/dev/null | grep -E '^'$1'/$' 		| sed -r -e 's/^([^-]+)-(.+)\/$/\'$2'/' | grep "^$cur" ))
}
_foo () 
{ 
    local cur prev opts;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    opts="create list run destroy snapshot";
    runopts="$(ubuntu-emulator list | cut -f1)";
    case $prev in 
        run)
            COMPREPLY=($(compgen -W "$runopts" -- $cur));
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts" -- $cur));
    return 0
}
_fstypes () 
{ 
    local fss;
    if [[ -e /proc/filesystems ]]; then
        fss="$( cut -d'	' -f2 /proc/filesystems )
             $( awk '! /\*/ { print $NF }' /etc/filesystems 2>/dev/null )";
    else
        fss="$( awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2>/dev/null )
             $( awk '{ print $1 }' /etc/dfs/fstypes 2>/dev/null )
             $( [[ -d /etc/fs ]] && command ls /etc/fs )";
    fi;
    [[ -n $fss ]] && COMPREPLY+=($( compgen -W "$fss" -- "$cur" ))
}
_gem191 () 
{ 
    local cur prev completions;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    COMMANDS='build cert check cleanup contents dependency\
      environment fetch generate_index help install list\
      lock mirror outdated pristine query rdoc search server\
      sources specification uninstall unpack update which';
    GEM_OPTIONS='\
      -h --help\
      -v --version';
    COMMON_OPTIONS='\
      -h --help\
      -V --verbose --no-verbose\
      -q --quiet\
      --config-file\
      --backtrace\
      --debug';
    CERT_OPTIONS='\
      -a -add\
      -l --list\
      -r --remove\
      -b --build\
      -C --certificate\
      -K --private-key\
      -s --sign';
    CHECK_OPTIONS='\
      --verify\
      -a --alien\
      -t --test\
      -v --version';
    CLEANUP_OPTIONS='\
      -d --dry-run';
    CONTENTS_OPTIONS='\
      -v --version\
      -s --spec-dir\
      -l --lib-only --no-lib-only';
    DEPENDENCY_OPTIONS='\
      -v --version\
      --platform\
      -R --reverse-dependencies --no-reverse-dependencies\
      -p --pipe';
    ENVIRONMENT_OPTIONS='';
    FETCH_OPTIONS='\
      -v --version\
      --platform\
      -B --bulk-threshold\
      -p --http-proxy --no-http-proxy\
      --source';
    GENERATE_INDEX_OPTIONS='\
      -d --directory';
    HELP_OPTIONS=$COMMANDS;
    INSTALL_OPTIONS='\
      --platform\
      -v --version\
      -i --install-dir\
      -d --rdoc --no-rdoc\
      --ri --no-ri\
      -E --env-shebang\
      -f --force --no-force\
      -t --test --no-test\
      -w --wrappers --no-wrappers\
      -P --trust-policy\
      --ignore-dependencies\
      -y --include-dependencies\
      --format-executable --no-format-executable\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    LIST_OPTIONS='\
      -d --details --no-details\
      --versions --no-versions\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    LOCK_OPTIONS='\
      -s --strict --no-strict';
    MIRROR_OPTIONS='';
    OUTDATED_OPTIONS='\
      --platform';
    PRISTINE_OPTIONS='\
      --all\
      -v --version';
    QUERY_OPTIONS='\
      -n --name-matches\
      -d --details --no-details\
      --versions --no-versions\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    RDOC_OPTIONS='\
      --all\
      --rdoc --no-rdoc\
      --ri --no-ri\
      -v --version';
    SEARCH_OPTIONS='\
      -d --details --no-details\
      --versions --no-versions\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    SERVER_OPTIONS='\
      -p --port\
      -d --dir\
      --daemon --no-daemon';
    SOURCES_OPTIONS='\
      -a --add\
      -l --list\
      -r --remove\
      -u --update\
      -c --clear-all';
    SPECIFICATION_OPTIONS='\
      -v --version\
      --platform\
      --all\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    UNINSTALL_OPTIONS='\
      -a --all --no-all\
      -i --ignore-dependencies --no-ignore-dependencies\
      -x --executables --no-executables\
      -v --version\
      --platform';
    UNPACK_OPTIONS='\
      --target\
      -v --version';
    UPDATE_OPTIONS='\
      --system\
      --platform\
      -i --install-dir\
      -d --rdoc --no-rdoc\
      --ri --no-ri\
      -E --env-shebang\
      -f --force --no-force\
      -t --test --no-test\
      -w --wrappers --no-wrappers\
      -P --trust-policy\
      --ignore-dependencies\
      -y --include-dependencies\
      --format-executable --no-format-executable\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    WHICH_OPTIONS='\
      -a --all --no-all\
      -g --gems-first --no-gems-first';
    case "${prev}" in 
        build)
            completions="$COMMON_OPTIONS $BUILD_OPTIONS"
        ;;
        cert)
            completions="$COMMON_OPTIONS $CERT_OPTIONS"
        ;;
        check)
            completions="$COMMON_OPTIONS $CHECK_OPTIONS"
        ;;
        cleanup)
            completions="$COMMON_OPTIONS $CLEANUP_OPTIONS"
        ;;
        contents)
            completions="$COMMON_OPTIONS $CONTENTS_OPTIONS"
        ;;
        dependency)
            completions="$COMMON_OPTIONS $DEPENDENCY_OPTIONS"
        ;;
        environment)
            completions="$COMMON_OPTIONS $ENVIRONMENT_OPTIONS"
        ;;
        fetch)
            completions="$COMMON_OPTIONS $FETCH_OPTIONS"
        ;;
        generate_index)
            completions="$COMMON_OPTIONS $GENERATE_INDEX_OPTIONS"
        ;;
        help)
            completions="$COMMON_OPTIONS $HELP_OPTIONS"
        ;;
        install)
            completions="$COMMON_OPTIONS $INSTALL_OPTIONS"
        ;;
        list)
            completions="$COMMON_OPTIONS $LIST_OPTIONS"
        ;;
        lock)
            completions="$COMMON_OPTIONS $LOCK_OPTIONS"
        ;;
        mirror)
            completions="$COMMON_OPTIONS $MIRROR_OPTIONS"
        ;;
        outdated)
            completions="$COMMON_OPTIONS $OUTDATED_OPTIONS"
        ;;
        pristine)
            completions="$COMMON_OPTIONS $PRISTINE_OPTIONS"
        ;;
        query)
            completions="$COMMON_OPTIONS $QUERY_OPTIONS"
        ;;
        rdoc)
            completions="$COMMON_OPTIONS $RDOC_OPTIONS"
        ;;
        search)
            completions="$COMMON_OPTIONS $SEARCH_OPTIONS"
        ;;
        server)
            completions="$COMMON_OPTIONS $SERVER_OPTIONS"
        ;;
        sources)
            completions="$COMMON_OPTIONS $SOURCES_OPTIONS"
        ;;
        specification)
            completions="$COMMON_OPTIONS $SPECIFICATION_OPTIONS"
        ;;
        uninstall)
            completions="$COMMON_OPTIONS $UNINSTALL_OPTIONS"
        ;;
        unpack)
            completions="$COMMON_OPTIONS $UNPACK_OPTIONS"
        ;;
        update)
            completions="$COMMON_OPTIONS $UPDATE_OPTIONS"
        ;;
        which)
            completions="$COMMON_OPTIONS $WHICH_OPTIONS"
        ;;
        *)
            completions="$COMMANDS $GEM_OPTIONS"
        ;;
    esac;
    COMPREPLY=($( compgen -W "$completions" -- $cur ));
    return 0
}
_get_comp_words_by_ref () 
{ 
    local exclude flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur vcword vprev vwords;
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in 
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in 
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash: $FUNCNAME(): \`${!OPTIND}': unknown argument" 1>&2;
                return 1
            ;;
        esac;
        let "OPTIND += 1";
    done;
    __get_cword_at_cursor_by_ref "$exclude" words cword cur;
    [[ -n $vcur ]] && { 
        upvars+=("$vcur");
        upargs+=(-v $vcur "$cur")
    };
    [[ -n $vcword ]] && { 
        upvars+=("$vcword");
        upargs+=(-v $vcword "$cword")
    };
    [[ -n $vprev && $cword -ge 1 ]] && { 
        upvars+=("$vprev");
        upargs+=(-v $vprev "${words[cword - 1]}")
    };
    [[ -n $vwords ]] && { 
        upvars+=("$vwords");
        upargs+=(-a${#words[@]} $vwords "${words[@]}")
    };
    (( ${#upvars[@]} )) && local "${upvars[@]}" && _upvars "${upargs[@]}"
}
_get_cword () 
{ 
    local LC_CTYPE=C;
    local cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    if [[ -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword-$2]}";
    else
        if [[ "${#words[cword]}" -eq 0 || "$COMP_POINT" == "${#COMP_LINE}" ]]; then
            printf "%s" "${words[cword]}";
        else
            local i;
            local cur="$COMP_LINE";
            local index="$COMP_POINT";
            for ((i = 0; i <= cword; ++i ))
            do
                while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                    cur="${cur:1}";
                    ((index--));
                done;
                if [[ "$i" -lt "$cword" ]]; then
                    local old_size="${#cur}";
                    cur="${cur#${words[i]}}";
                    local new_size="${#cur}";
                    index=$(( index - old_size + new_size ));
                fi;
            done;
            if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:$index}";
            fi;
        fi;
    fi
}
_get_first_arg () 
{ 
    local i;
    arg=;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_pword () 
{ 
    if [[ $COMP_CWORD -ge 1 ]]; then
        _get_cword "${@:-}" 1;
    fi
}
_gids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($( compgen -W '$( getent group | cut -d: -f3 )'             -- "$cur" ));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/group )' -- "$cur" ));
        fi;
    fi
}
_grub_editenv () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        create | list | set | unset)
            COMPREPLY=("");
            return
        ;;
    esac;
    __grubcomp "$(__grub_get_options_from_help)
                create list set unset"
}
_grub_install () 
{ 
    local cur prev last split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    last=$(__grub_get_last_option);
    _split_longopt && split=true;
    case "$prev" in 
        --boot-directory)
            _filedir -d;
            return
        ;;
        --disk-module)
            __grubcomp "biosdisk ata";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        case "$last" in 
            --modules)
                __grub_list_modules;
                return
            ;;
        esac;
        _filedir;
    fi
}
_grub_mkconfig () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkfont () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkimage () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -d | --directory | -p | --prefix)
            _filedir -d;
            return
        ;;
        -O | --format)
            local prog=${COMP_WORDS[0]};
            __grubcomp "$(LC_ALL=C $prog --help |                         awk -F ":" '/available formats/ { print $2 }' |                         sed 's/, / /g')";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkpasswd_pbkdf2 () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkrescue () 
{ 
    local cur prev last;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    last=$(__grub_get_last_option);
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        case "$last" in 
            --modules)
                __grub_list_modules;
                return
            ;;
        esac;
        _filedir;
    fi
}
_grub_probe () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -t | --target)
            local prog=${COMP_WORDS[0]};
            __grubcomp "$(LC_ALL=C $prog --help |                         awk -F "[()]" '/--target=/ { print $2 }' |                         sed 's/|/ /g')";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_script_check () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_set_entry () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        --boot-directory)
            _filedir -d;
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        __grub_list_menuentries;
    fi
}
_grub_setup () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -d | --directory)
            _filedir -d;
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_have () 
{ 
    PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin type $1 &> /dev/null
}
_hg () 
{ 
    local cur prev cmd cmd_index opts i aliashg;
    local global_args='--cwd|-R|--repository';
    local hg="$1";
    local canonical=0;
    aliashg=$(alias $hg 2>/dev/null);
    if [[ -n "$aliashg" ]]; then
        aliashg=${aliashg#"alias $hg='"};
        aliashg=${aliashg%"'"};
        hg=$aliashg;
    fi;
    COMPREPLY=();
    cur="$2";
    prev="$3";
    for ((i=1; $i<=$COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            if [[ ${COMP_WORDS[i-1]} != @($global_args) ]]; then
                cmd="${COMP_WORDS[i]}";
                cmd_index=$i;
                break;
            fi;
        fi;
    done;
    if [[ "$cur" == -* ]]; then
        if [ "$(type -t "_hg_opt_$cmd")" = function ] && "_hg_opt_$cmd"; then
            _hg_fix_wordlist;
            return;
        fi;
        opts=$(_hg_cmd debugcomplete --options "$cmd");
        COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$opts' -- "$cur"));
        _hg_fix_wordlist;
        return;
    fi;
    case "$prev" in 
        -R | --repository)
            _hg_paths;
            _hg_repos;
            _hg_fix_wordlist;
            return
        ;;
        --cwd)
            _hg_fix_wordlist;
            return
        ;;
    esac;
    if [ -z "$cmd" ] || [ $COMP_CWORD -eq $i ]; then
        _hg_commands;
        _hg_fix_wordlist;
        return;
    fi;
    local help;
    if _hg_command_specific; then
        _hg_fix_wordlist;
        return;
    fi;
    help=$(_hg_cmd help "$cmd");
    if [ $? -ne 0 ]; then
        return;
    fi;
    cmd=${help#hg };
    cmd=${cmd%%[' 
']*};
    canonical=1;
    _hg_command_specific;
    _hg_fix_wordlist
}
_hg_bookmarks () 
{ 
    local bookmarks="$(_hg_cmd bookmarks -q)";
    local IFS='
';
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$bookmarks' -- "$cur"))
}
_hg_branches () 
{ 
    local branches="$(_hg_cmd branches -q)";
    local IFS='
';
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$branches' -- "$cur"))
}
_hg_cmd () 
{ 
    HGPLAIN=1 "$hg" "$@" 2> /dev/null
}
_hg_cmd_bisect () 
{ 
    local i subcmd;
    for ((i=cmd_index+1; i<=COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            if [[ ${COMP_WORDS[i-1]} != @($global_args) ]]; then
                subcmd="${COMP_WORDS[i]}";
                break;
            fi;
        fi;
    done;
    if [ -z "$subcmd" ] || [ $COMP_CWORD -eq $i ] || [ "$subcmd" = help ]; then
        COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W 'bad good help init next reset' -- "$cur"));
        return;
    fi;
    case "$subcmd" in 
        good | bad)
            _hg_labels
        ;;
    esac;
    return
}
_hg_cmd_bookmarks () 
{ 
    _hg_bookmarks;
    return
}
_hg_cmd_email () 
{ 
    case "$prev" in 
        -c | --cc | -t | --to | -f | --from | --bcc)
            if [ "$(type -t _hg_emails)" = function ]; then
                local arg=to;
                if [[ "$prev" == @(-f|--from) ]]; then
                    arg=from;
                fi;
                local addresses=$(_hg_emails $arg);
                COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$addresses' -- "$cur"));
            fi;
            return
        ;;
        -m | --mbox)
            return
        ;;
        -s | --subject)
            return
        ;;
    esac;
    _hg_labels;
    return
}
_hg_cmd_qclone () 
{ 
    local count=$(_hg_count_non_option);
    if [ $count = 1 ]; then
        _hg_paths;
    fi;
    _hg_repos
}
_hg_cmd_qcommit () 
{ 
    local root=$(_hg_cmd root);
    local files=$(cd "$root/.hg/patches" && _hg_cmd status -nmar);
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$files' -- "$cur"))
}
_hg_cmd_qdelete () 
{ 
    local qcmd=qunapplied;
    if [[ "$prev" = @(-r|--rev) ]]; then
        qcmd=qapplied;
    fi;
    _hg_ext_mq_patchlist $qcmd
}
_hg_cmd_qfinish () 
{ 
    if [[ "$prev" = @(-a|--applied) ]]; then
        return;
    fi;
    _hg_ext_mq_patchlist qapplied
}
_hg_cmd_qfold () 
{ 
    _hg_ext_mq_patchlist qunapplied
}
_hg_cmd_qgoto () 
{ 
    if [[ "$prev" = @(-n|--name) ]]; then
        _hg_ext_mq_queues;
        return;
    fi;
    _hg_ext_mq_patchlist qseries
}
_hg_cmd_qguard () 
{ 
    local prefix='';
    if [[ "$cur" == +* ]]; then
        prefix=+;
    else
        if [[ "$cur" == -* ]]; then
            prefix=-;
        fi;
    fi;
    local ncur=${cur#[-+]};
    if ! [ "$prefix" ]; then
        _hg_ext_mq_patchlist qseries;
        return;
    fi;
    local guards=$(_hg_ext_mq_guards);
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -P $prefix -W '$guards' -- "$ncur"))
}
_hg_cmd_qheader () 
{ 
    _hg_ext_mq_patchlist qseries
}
_hg_cmd_qpop () 
{ 
    if [[ "$prev" = @(-n|--name) ]]; then
        _hg_ext_mq_queues;
        return;
    fi;
    _hg_ext_mq_patchlist qapplied
}
_hg_cmd_qpush () 
{ 
    if [[ "$prev" = @(-n|--name) ]]; then
        _hg_ext_mq_queues;
        return;
    fi;
    _hg_ext_mq_patchlist qunapplied
}
_hg_cmd_qqueue () 
{ 
    local q;
    local queues;
    local opts="--list --create --rename --delete --purge";
    queues=$( _hg_cmd qqueue --quiet );
    COMPREPLY=($( compgen -W "${opts} ${queues}" "${cur}" ))
}
_hg_cmd_qrename () 
{ 
    _hg_ext_mq_patchlist qseries
}
_hg_cmd_qsave () 
{ 
    if [[ "$prev" = @(-n|--name) ]]; then
        _hg_ext_mq_queues;
        return;
    fi
}
_hg_cmd_qselect () 
{ 
    local guards=$(_hg_ext_mq_guards);
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$guards' -- "$cur"))
}
_hg_cmd_rebase () 
{ 
    if [[ "$prev" = @(-s|--source|-d|--dest|-b|--base|-r|--rev) ]]; then
        _hg_labels;
        return;
    fi
}
_hg_cmd_shelve () 
{ 
    if [[ "$prev" = @(-d|--delete|-l|--list) ]]; then
        _hg_shelves;
    else
        _hg_status "mard";
    fi
}
_hg_cmd_sign () 
{ 
    _hg_labels
}
_hg_cmd_strip () 
{ 
    if [[ "$prev" = @(-B|--bookmark) ]]; then
        _hg_bookmarks;
        return;
    fi;
    _hg_labels
}
_hg_cmd_transplant () 
{ 
    case "$prev" in 
        -s | --source)
            _hg_paths;
            _hg_repos;
            return
        ;;
        --filter)
            return
        ;;
    esac;
    _hg_labels;
    return
}
_hg_cmd_unshelve () 
{ 
    _hg_shelves
}
_hg_command_specific () 
{ 
    if [ "$(type -t "_hg_cmd_$cmd")" = function ]; then
        "_hg_cmd_$cmd";
        return 0;
    fi;
    if [ "$cmd" != status ]; then
        case "$prev" in 
            -r | --rev)
                if [[ $canonical = 1 || status != "$cmd"* ]]; then
                    _hg_labels;
                    return 0;
                fi;
                return 1
            ;;
            -B | --bookmark)
                if [[ $canonical = 1 || status != "$cmd"* ]]; then
                    _hg_bookmarks;
                    return 0;
                fi;
                return 1
            ;;
            -b | --branch)
                if [[ $canonical = 1 || status != "$cmd"* ]]; then
                    _hg_branches;
                    return 0;
                fi;
                return 1
            ;;
        esac;
    fi;
    local aliascmd=$(_hg_cmd showconfig alias.$cmd | awk '{print $1}');
    [ -n "$aliascmd" ] && cmd=$aliascmd;
    case "$cmd" in 
        help)
            _hg_commands
        ;;
        export)
            if _hg_ext_mq_patchlist qapplied && [ "${COMPREPLY[*]}" ]; then
                return 0;
            fi;
            _hg_labels
        ;;
        manifest | update | up | checkout | co)
            _hg_labels
        ;;
        pull | push | outgoing | incoming)
            _hg_paths;
            _hg_repos
        ;;
        paths)
            _hg_paths
        ;;
        add)
            _hg_status "u"
        ;;
        merge)
            _hg_labels
        ;;
        commit | ci | record)
            _hg_status "mar"
        ;;
        remove | rm)
            _hg_debugpathcomplete -n
        ;;
        forget)
            _hg_debugpathcomplete -fa
        ;;
        diff)
            _hg_status "mar"
        ;;
        revert)
            _hg_debugpathcomplete
        ;;
        clone)
            local count=$(_hg_count_non_option);
            if [ $count = 1 ]; then
                _hg_paths;
            fi;
            _hg_repos
        ;;
        debugindex | debugindexdot)
            COMPREPLY=(${COMPREPLY[@]:-} $(compgen -f -X "!*.i" -- "$cur"))
        ;;
        debugdata)
            COMPREPLY=(${COMPREPLY[@]:-} $(compgen -f -X "!*.d" -- "$cur"))
        ;;
        *)
            return 1
        ;;
    esac;
    return 0
}
_hg_commands () 
{ 
    local commands;
    commands="$(HGPLAINEXCEPT=alias _hg_cmd debugcomplete "$cur")" || commands="";
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$commands' -- "$cur"))
}
_hg_count_non_option () 
{ 
    local i count=0;
    local filters="$1";
    for ((i=1; $i<=$COMP_CWORD; i++))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            if [[ ${COMP_WORDS[i-1]} == @($filters|$global_args) ]]; then
                continue;
            fi;
            count=$(($count + 1));
        fi;
    done;
    echo $(($count - 1))
}
_hg_debugpathcomplete () 
{ 
    local files="$(_hg_cmd debugpathcomplete $1 "$cur")";
    local IFS='
';
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$files' -- "$cur"))
}
_hg_ext_mq_guards () 
{ 
    _hg_cmd qselect --series | sed -e 's/^.//'
}
_hg_ext_mq_patchlist () 
{ 
    local patches;
    patches=$(_hg_cmd $1);
    if [ $? -eq 0 ] && [ "$patches" ]; then
        COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$patches' -- "$cur"));
        return 0;
    fi;
    return 1
}
_hg_ext_mq_queues () 
{ 
    local root=$(_hg_cmd root);
    local n;
    for n in $(cd "$root"/.hg && compgen -d -- "$cur");
    do
        if [ "$n" != patches ] && [ -e "$root/.hg/$n/series" ]; then
            COMPREPLY=(${COMPREPLY[@]:-} "$n");
        fi;
    done
}
_hg_fix_wordlist () 
{ 
    local LASTCHAR=' ';
    if [ ${#COMPREPLY[@]} = 1 ]; then
        [ -d "$COMPREPLY" ] && LASTCHAR=/;
        COMPREPLY=$(printf %q%s "$COMPREPLY" "$LASTCHAR");
    else
        for ((i=0; i < ${#COMPREPLY[@]}; i++))
        do
            [ -d "${COMPREPLY[$i]}" ] && COMPREPLY[$i]=${COMPREPLY[$i]}/;
        done;
    fi
}
_hg_labels () 
{ 
    local labels="$(_hg_cmd debugnamecomplete "$cur")";
    local IFS='
';
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$labels' -- "$cur"))
}
_hg_opt_qguard () 
{ 
    local i;
    for ((i=cmd_index+1; i<=COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            if [[ ${COMP_WORDS[i-1]} != @($global_args) ]]; then
                _hg_cmd_qguard;
                return 0;
            fi;
        else
            if [ "${COMP_WORDS[i]}" = -- ]; then
                _hg_cmd_qguard;
                return 0;
            fi;
        fi;
    done;
    return 1
}
_hg_paths () 
{ 
    local paths="$(_hg_cmd paths -q)";
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$paths' -- "$cur"))
}
_hg_repos () 
{ 
    local i;
    for i in $(compgen -d -- "$cur");
    do
        test ! -d "$i"/.hg || COMPREPLY=(${COMPREPLY[@]:-} "$i");
    done
}
_hg_shelves () 
{ 
    local shelves="$(_hg_cmd shelve -ql)";
    local IFS='
';
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$shelves' -- "$cur"))
}
_hg_status () 
{ 
    local files="$(_hg_cmd status -n$1 "glob:$cur**")";
    local IFS='
';
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$files' -- "$cur"))
}
_hrule () 
{ 
    local R=$?;
    local COLORBG=${3:-0};
    local COLORFG=${2:-NONE};
    local CHARITEM=${1:--};
    which resize &> /dev/null && eval `resize`;
    declare -i COLUMNS=${COLUMNS:-80};
    [[ $COLORFG == NONE ]] || echo -ne "[38;5;$[COLORFG];48;5;$[COLORBG]m";
    for ((i=0; i<COLUMNS; i+=${#CHARITEM}))
    do
        if [[ $[ COLUMNS-i ] > ${#CHARITEM} ]]; then
            echo -ne "$CHARITEM";
        else
            echo -ne "${CHARITEM: 0:$[COLUMNS-i]}";
        fi;
    done;
    [[ $COLORFG == NONE ]] || echo -ne '[0m';
    return $R
}
_init_completion () 
{ 
    local exclude= flag outx errx inx OPTIND=1;
    while getopts "n:e:o:i:s" flag "$@"; do
        case $flag in 
            n)
                exclude+=$OPTARG
            ;;
            e)
                errx=$OPTARG
            ;;
            o)
                outx=$OPTARG
            ;;
            i)
                inx=$OPTARG
            ;;
            s)
                split=false;
                exclude+==
            ;;
        esac;
    done;
    COMPREPLY=();
    local redir="@(?([0-9])<|?([0-9&])>?(>)|>&)";
    _get_comp_words_by_ref -n "$exclude<>&" cur prev words cword;
    _variables && return 1;
    if [[ $cur == $redir* || $prev == $redir ]]; then
        local xspec;
        case $cur in 
            2'>'*)
                xspec=$errx
            ;;
            *'>'*)
                xspec=$outx
            ;;
            *'<'*)
                xspec=$inx
            ;;
            *)
                case $prev in 
                    2'>'*)
                        xspec=$errx
                    ;;
                    *'>'*)
                        xspec=$outx
                    ;;
                    *'<'*)
                        xspec=$inx
                    ;;
                esac
            ;;
        esac;
        cur="${cur##$redir}";
        _filedir $xspec;
        return 1;
    fi;
    local i skip;
    for ((i=1; i < ${#words[@]}; 1))
    do
        if [[ ${words[i]} == $redir* ]]; then
            [[ ${words[i]} == $redir ]] && skip=2 || skip=1;
            words=("${words[@]:0:i}" "${words[@]:i+skip}");
            [[ $i -le $cword ]] && cword=$(( cword - skip ));
        else
            i=$(( ++i ));
        fi;
    done;
    [[ $cword -le 0 ]] && return 1;
    prev=${words[cword-1]};
    [[ -n ${split-} ]] && _split_longopt && split=true;
    return 0
}
_installed_modules () 
{ 
    COMPREPLY=($( compgen -W "$( PATH="$PATH:/sbin" lsmod |         awk '{if (NR != 1) print $1}' )" -- "$1" ))
}
_ip_addresses () 
{ 
    local PATH=$PATH:/sbin;
    COMPREPLY+=($( compgen -W         "$( { LC_ALL=C ifconfig -a || ip addr show; } 2>/dev/null |
            sed -ne 's/.*addr:\([^[:space:]]*\).*/\1/p'                 -ne 's|.*inet[[:space:]]\{1,\}\([^[:space:]/]*\).*|\1|p' )"         -- "$cur" ))
}
_kernel_versions () 
{ 
    COMPREPLY=($( compgen -W '$( command ls /lib/modules )' -- "$cur" ))
}
_kernels () 
{ 
    COMPREPLY=($( cd /lib/modules && compgen -d -- "$cur" ))
}
_known_hosts () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    local options;
    [[ "$1" == -a || "$2" == -a ]] && options=-a;
    [[ "$1" == -c || "$2" == -c ]] && options+=" -c";
    _known_hosts_real $options -- "$cur"
}
_known_hosts_real () 
{ 
    local configfile flag prefix;
    local cur curd awkcur user suffix aliases i host;
    local -a kh khd config;
    local OPTIND=1;
    while getopts "acF:p:" flag "$@"; do
        case $flag in 
            a)
                aliases='yes'
            ;;
            c)
                suffix=':'
            ;;
            F)
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
        esac;
    done;
    [[ $# -lt $OPTIND ]] && echo "error: $FUNCNAME: missing mandatory argument CWORD";
    cur=${!OPTIND};
    let "OPTIND += 1";
    [[ $# -ge $OPTIND ]] && echo "error: $FUNCNAME("$@"): unprocessed arguments:" $(while [[ $# -ge $OPTIND ]]; do printf '%s\n' ${!OPTIND}; shift; done);
    [[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [[ -n $configfile ]]; then
        [[ -r $configfile ]] && config+=("$configfile");
    else
        for i in /etc/ssh/ssh_config ~/.ssh/config ~/.ssh2/config;
        do
            [[ -r $i ]] && config+=("$i");
        done;
    fi;
    if [[ ${#config[@]} -gt 0 ]]; then
        local OIFS=$IFS IFS='
' j;
        local -a tmpkh;
        tmpkh=($( awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u ));
        IFS=$OIFS;
        for i in "${tmpkh[@]}";
        do
            while [[ $i =~ ^([^\"]*)\"([^\"]*)\"(.*)$ ]]; do
                i=${BASH_REMATCH[1]}${BASH_REMATCH[3]};
                j=${BASH_REMATCH[2]};
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
            for j in $i;
            do
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
        done;
    fi;
    if [[ -z $configfile ]]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [[ -r $i ]] && kh+=("$i");
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [[ -d $i ]] && khd+=("$i"/*pub);
        done;
    fi;
    if [[ ${#kh[@]} -gt 0 || ${#khd[@]} -gt 0 ]]; then
        awkcur=${cur//\//\\\/};
        awkcur=${awkcur//\./\\\.};
        curd=$awkcur;
        if [[ "$awkcur" == [0-9]*[.:]* ]]; then
            awkcur="^$awkcur[.:]*";
        else
            if [[ "$awkcur" == [0-9]* ]]; then
                awkcur="^$awkcur.*[.:]";
            else
                if [[ -z $awkcur ]]; then
                    awkcur="[a-z.:]";
                else
                    awkcur="^$awkcur";
                fi;
            fi;
        fi;
        if [[ ${#kh[@]} -gt 0 ]]; then
            COMPREPLY+=($( awk 'BEGIN {FS=","}
            /^\s*[^|\#]/ {
            sub("^@[^ ]+ +", ""); \
            sub(" .*$", ""); \
            for (i=1; i<=NF; ++i) { \
            sub("^\\[", "", $i); sub("\\](:[0-9]+)?$", "", $i); \
            if ($i !~ /[*?]/ && $i ~ /'"$awkcur"'/) {print $i} \
            }}' "${kh[@]}" 2>/dev/null ));
        fi;
        if [[ ${#khd[@]} -gt 0 ]]; then
            for i in "${khd[@]}";
            do
                if [[ "$i" == *key_22_$curd*.pub && -r "$i" ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    COMPREPLY+=($host);
                fi;
            done;
        fi;
        for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
        do
            COMPREPLY[i]=$prefix$user${COMPREPLY[i]}$suffix;
        done;
    fi;
    if [[ ${#config[@]} -gt 0 && -n "$aliases" ]]; then
        local hosts=$( sed -ne 's/^[ \t]*[Hh][Oo][Ss][Tt]\([Nn][Aa][Mm][Ee]\)\{0,1\}['"$'\t '"']\{1,\}\([^#*?]*\)\(#.*\)\{0,1\}$/\2/p' "${config[@]}" );
        COMPREPLY+=($( compgen -P "$prefix$user"             -S "$suffix" -W "$hosts" -- "$cur" ));
    fi;
    COMPREPLY+=($( compgen -W         "$( ruptime 2>/dev/null | awk '!/^ruptime:/ { print $1 }' )"         -- "$cur" ));
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1} ]]; then
        COMPREPLY+=($( compgen -A hostname -P "$prefix$user" -S "$suffix" -- "$cur" ));
    fi;
    __ltrim_colon_completions "$prefix$user$cur";
    return 0
}
_loexp_ () 
{ 
    local c=${COMP_WORDS[COMP_CWORD]};
    local a="${COMP_LINE}";
    local e s g=0 cd dc t="";
    local IFS;
    shopt -q extglob && g=1;
    test $g -eq 0 && shopt -s extglob;
    cd='*-?(c)d*';
    dc='*-d?(c)*';
    case "${1##*/}" in 
        lomath)
            e='!*.+(sxm|SXM|smf|SMF|mml|MML|odf|ODF)'
        ;;
        lobase)
            e='!*.+(odb|ODB)'
        ;;
        libreoffice)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG|doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxm|SXM|smf|SMF|mml|MML|odf|ODF|sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX|odb|ODB|sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX|sxg|SXG|odm|ODM|sgl|SGL|stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX|htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        unopkg)
            e='!*.+(oxt|OXT)'
        ;;
        loweb)
            e='!*.+(htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        loimpress)
            e='!*.+(sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX)'
        ;;
        localc)
            e='!*.+(sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX)'
        ;;
        lofromtemplate)
            e='!*.+(stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX)'
        ;;
        loffice)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG|doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxm|SXM|smf|SMF|mml|MML|odf|ODF|sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX|odb|ODB|sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX|sxg|SXG|odm|ODM|sgl|SGL|stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX|htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        lowriter)
            e='!*.+(doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxg|SXG|odm|ODM|sgl|SGL)'
        ;;
        lodraw)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG)'
        ;;
        *)
            e='!*'
        ;;
    esac;
    case "$(complete -p ${1##*/} 2> /dev/null)" in 
        *-d*)

        ;;
        *)
            s="-S/"
        ;;
    esac;
    IFS='
';
    case "$c" in 
        \$\(*\))
            eval COMPREPLY=\(${c}\)
        ;;
        \$\(*)
            COMPREPLY=($(compgen -c -P '$(' -S ')'  -- ${c#??}))
        ;;
        \`*\`)
            eval COMPREPLY=\(${c}\)
        ;;
        \`*)
            COMPREPLY=($(compgen -c -P '\`' -S '\`' -- ${c#?}))
        ;;
        \$\{*\})
            eval COMPREPLY=\(${c}\)
        ;;
        \$\{*)
            COMPREPLY=($(compgen -v -P '${' -S '}'  -- ${c#??}))
        ;;
        \$*)
            COMPREPLY=($(compgen -v -P '$'          -- ${c#?}))
        ;;
        \~*/*)
            COMPREPLY=($(compgen -f -X "$e"         -- ${c}))
        ;;
        \~*)
            COMPREPLY=($(compgen -u ${s}	 	-- ${c}))
        ;;
        *@*)
            COMPREPLY=($(compgen -A hostname -P '@' -S ':' -- ${c#*@}))
        ;;
        *[*?[]*)
            COMPREPLY=($(compgen -G "${c}"))
        ;;
        *[?*+\!@]\(*\)*)
            if test $g -eq 0; then
                COMPREPLY=($(compgen -f -X "$e" -- $c));
                test $g -eq 0 && shopt -u extglob;
                return;
            fi;
            COMPREPLY=($(compgen -G "${c}"))
        ;;
        *)
            if test "$c" = ".."; then
                COMPREPLY=($(compgen -d -X "$e" -S / ${_nosp} -- $c));
            else
                for s in $(compgen -f -X "$e" -- $c);
                do
                    if test -d $s; then
                        COMPREPLY=(${COMPREPLY[@]} $(compgen -f -X "$e" -S / -- $s));
                    else
                        if test -z "$t"; then
                            COMPREPLY=(${COMPREPLY[@]} $s);
                        else
                            case "$(file -b $s 2> /dev/null)" in 
                                $t)
                                    COMPREPLY=(${COMPREPLY[@]} $s)
                                ;;
                            esac;
                        fi;
                    fi;
                done;
            fi
        ;;
    esac;
    test $g -eq 0 && shopt -u extglob
}
_longopt () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case "${prev,,}" in 
        --help | --usage | --version)
            return 0
        ;;
        --*dir*)
            _filedir -d;
            return 0
        ;;
        --*file* | --*path*)
            _filedir;
            return 0
        ;;
        --+([-a-z0-9_]))
            local argtype=$( $1 --help 2>&1 | sed -ne                 "s|.*$prev\[\{0,1\}=[<[]\{0,1\}\([-A-Za-z0-9_]\{1,\}\).*|\1|p" );
            case ${argtype,,} in 
                *dir*)
                    _filedir -d;
                    return 0
                ;;
                *file* | *path*)
                    _filedir;
                    return 0
                ;;
            esac
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             sed -ne 's/.*\(--[-A-Za-z0-9]\{1,\}=\{0,1\}\).*/\1/p' | sort -u )"             -- "$cur" ));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
    else
        if [[ "$1" == @(mk|rm)dir ]]; then
            _filedir -d;
        else
            _filedir;
        fi;
    fi
}
_lsar () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -p | -password)
            return 0
        ;;
        -e | -encoding | -E | -password-encoding)
            COMPREPLY=($( compgen -W                     "$(lsar -e list | sed -n 's/, //g;s/[()]//g;s/^  \* //p')"                     -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-l -long -t -test -p -password -e \
                -encoding -E -password-encoding -pe -print-encoding -i \
                -indexes -j -json -ja -json-ascii -nr -no-recursion -h \
                -help' -- "$cur" ));
    else
        _filedir '@(rar|zip|tar|gz|bz2|cab|7z|msi|exe|iso|lzma|xz|zipx|lzh|cpio|rpm|lha|z|tbz|tbz2|xar|pit|arc|nds|zoo|lz|deb)';
    fi
}
_mac_addresses () 
{ 
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    COMPREPLY+=($(         { LC_ALL=C ifconfig -a || ip link show; } 2>/dev/null | sed -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]].*|\2|p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]]*$|\2|p"
        ));
    COMPREPLY+=($( { arp -an || ip neigh show; } 2>/dev/null | sed -ne         "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p" ));
    COMPREPLY+=($( sed -ne         "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2>/dev/null ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
    __ltrim_colon_completions "$cur"
}
_minimal () 
{ 
    _longopt "$@"
}
_modules () 
{ 
    local modpath;
    modpath=/lib/modules/$1;
    COMPREPLY=($( compgen -W "$( command ls -RL $modpath 2>/dev/null |         sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.[gx]z\)\{0,1\}$/\1/p' )" -- "$cur" ))
}
_ncpus () 
{ 
    local var=NPROCESSORS_ONLN;
    [[ $OSTYPE == *linux* ]] && var=_$var;
    local n=$( getconf $var 2>/dev/null );
    printf %s ${n:-1}
}
_ninja_target () 
{ 
    local cur targets dir line targets_command OPTIND;
    cur="${COMP_WORDS[COMP_CWORD]}";
    if [[ "$cur" == "--"* ]]; then
        COMPREPLY=($(compgen -P '--' -W 'version' -- "${cur:2}"));
    else
        dir=".";
        line=$(echo ${COMP_LINE} | cut -d" " -f 2-);
        while getopts C:f:j:l:k:nvd:t: opt "${line[@]}"; do
            case $opt in 
                C)
                    dir="$OPTARG"
                ;;
            esac;
        done;
        targets_command="ninja -C ${dir} -t targets all";
        targets=$((${targets_command} 2>/dev/null) | awk -F: '{print $1}');
        COMPREPLY=($(compgen -W "$targets" -- "$cur"));
    fi;
    return
}
_pacat () 
{ 
    local cur prev comps;
    local flags='-h --help --version -r --record -p --playback -v --verbose -s
                --server= -d --device= -n --client-name= --stream-name= --volume=
                --rate= --format= --channels= --channel-map= --fix-format --fix-rate
                --fix-channels --no-remix --no-remap --latency= --process-time=
                --latency-msec= --process-time-msec= --property= --raw --passthrough
                --file-format= --list-file-formats --monitor-stream=';
    _init_completion -n = || return;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        --device=*)
            cur=${cur#*=};
            comps=$(__sinks);
            comps+=" "$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --monitor-stream=*)
            cur=${cur#*=};
            comps=$(__sink_inputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --rate=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W '32000 44100 48000 9600 192000' -- "$cur"))
        ;;
        --file-format=*)
            cur=${cur#*=};
            comps=$(_pacat_file_formats);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --*=*)

        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
        *)
            _filedir
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
        -d)
            comps=$(__sinks);
            comps+=" "$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
    esac
}
_pacat_file_formats () 
{ 
    while IFS='	' read name _; do
        printf "%s\n" "$name";
    done < <(pacat --list-file-formats 2> /dev/null)
}
_pacmd () 
{ 
    local cur prev words cword preprev command;
    local comps;
    local flags='-h --help --version';
    local commands=(exit help list-modules list-cards list-sinks list-sources list-clients list-samples list-sink-inputs list-source-outputs stat info load-module unload-module describe-module set-sink-volume set-source-volume set-sink-input-volume set-source-output-volume set-sink-mute set-source-mut set-sink-input-mute set-source-output-mute update-sink-proplist update-source-proplist update-sink-input-proplist update-source-output-proplist set-default-sink set-default-source kill-client kill-sink-input kill-source-output play-sample remove-sample load-sample load-sample-lazy load-sample-dir-lazy play-file dump move-sink-input move-source-output suspend-sink suspend-source suspend set-card-profile set-sink-port set-source-port set-port-latency-offset set-log-target set-log-level set-log-meta set-log-time set-log-backtrace);
    _init_completion -n = || return;
    preprev=${words[$cword-2]};
    for word in "${COMP_WORDS[@]}";
    do
        if in_array "$word" "${commands[@]}"; then
            command=$word;
            break;
        fi;
    done;
    case $preprev in 
        play-sample | play-file)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        load-sample*)
            _filedir
        ;;
        move-sink-input)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-source-output)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card-profile)
            comps=$(__profiles);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*port*)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-mute)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        set-sink-formats)

        ;;
    esac;
    case $prev in 
        list-*)

        ;;
        describe-module | load-module)
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        unload-module)
            comps=$(__loaded_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        load-sample-dir-lazy)
            _filedir -d
        ;;
        play-file)
            _filedir
        ;;
        *sink-input*)
            comps=$(__sink_inputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source-output*)
            comps=$(__source_outputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink*)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source*)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-port-*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-log-target)
            COMPREPLY=($(compgen -W 'auto syslog stderr file: newfile:' -- "$cur"))
        ;;
        set-log-level)
            COMPREPLY=($(compgen -W '{0..4}' -- "$cur"))
        ;;
        set-log-meta | set-log-time | suspend)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
    esac;
    case $cur in 
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"))
        ;;
        suspend)
            COMPREPLY=($(compgen -W 'suspend suspend-sink suspend-source' -- "$cur"))
        ;;
        load-sample)
            COMPREPLY=($(compgen -W 'load-sample load-sample-lazy load-sample-dir-lazy' -- "$cur"))
        ;;
        *)
            [[ -z $command ]] && COMPREPLY=($(compgen -W '${commands[*]}' -- "$cur"))
        ;;
    esac
}
_pactl () 
{ 
    local cur prev words cword preprev command;
    local comps;
    local flags='-h --help --version -s --server= --client-name=';
    local list_types='short sinks sources sink-inputs source-outputs cards
                    modules samples clients';
    local commands=(stat info list exit upload-sample play-sample remove-sample load-module unload-module move-sink-input move-source-output suspend-sink suspend-source set-card-profile set-sink-port set-source-port set-sink-volume set-source-volume set-sink-input-volume set-source-output-volume set-sink-mute set-source-mute set-sink-input-mute set-source-output-mute set-sink-formats set-port-latency-offset subscribe help);
    _init_completion -n = || return;
    preprev=${words[$cword-2]};
    for word in "${COMP_WORDS[@]}";
    do
        if in_array "$word" "${commands[@]}"; then
            command=$word;
            break;
        fi;
    done;
    case $preprev in 
        list)
            COMPREPLY=($(compgen -W 'short' -- "$cur"))
        ;;
        play-sample)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-sink-input)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-source-output)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card-profile)
            comps=$(__profiles);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-port)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-mute)
            COMPREPLY=($(compgen -W 'true false toggle' -- "$cur"))
        ;;
        set-sink-formats)

        ;;
        set-port-*)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --server)
            compopt +o nospace;
            _known_hosts_real "$cur"
        ;;
    esac;
    [[ -n $COMPREPLY ]] && return 0;
    case $prev in 
        list)
            COMPREPLY=($(compgen -W '${list_types[*]}' -- "$cur"))
        ;;
        upload-sample)
            _filedir
        ;;
        play-sample)

        ;;
        remove-sample)

        ;;
        load-module)
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        unload-module)
            comps=$(__loaded_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink-input*)
            comps=$(__sink_inputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source-output*)
            comps=$(__source_outputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-sink-formats)
            comps=$(__sinks_idx);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink*)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source*)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-port*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        -s)
            _known_hosts_real "$cur"
        ;;
    esac;
    [[ -n $COMPREPLY ]] && return 0;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
        *)
            [[ -z $command ]] && COMPREPLY=($(compgen -W '${commands[*]}' -- "$cur"))
        ;;
    esac
}
_padsp () 
{ 
    local cur prev;
    local flags='-h -s -n -m -M -S -D -d';
    _get_comp_words_by_ref cur prev;
    case $cur in 
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"))
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
    esac
}
_parse_help () 
{ 
    eval local cmd=$( quote "$1" );
    local line;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$( dequote "$cmd" )" ${2:---help} 2>&1
            ;;
        esac
    } | while read -r line; do
        [[ $line == *([ '	'])-* ]] || continue;
        while [[ $line =~ ((^|[^-])-[A-Za-z0-9?][[:space:]]+)\[?[A-Z0-9]+\]? ]]; do
            line=${line/"${BASH_REMATCH[0]}"/"${BASH_REMATCH[1]}"};
        done;
        __parse_options "${line// or /, }";
    done
}
_parse_usage () 
{ 
    eval local cmd=$( quote "$1" );
    local line match option i char;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$( dequote "$cmd" )" ${2:---usage} 2>&1
            ;;
        esac
    } | while read -r line; do
        while [[ $line =~ \[[[:space:]]*(-[^]]+)[[:space:]]*\] ]]; do
            match=${BASH_REMATCH[0]};
            option=${BASH_REMATCH[1]};
            case $option in 
                -?(\[)+([a-zA-Z0-9?]))
                    for ((i=1; i < ${#option}; i++ ))
                    do
                        char=${option:i:1};
                        [[ $char != '[' ]] && printf '%s\n' -$char;
                    done
                ;;
                *)
                    __parse_options "$option"
                ;;
            esac;
            line=${line#*"$match"};
        done;
    done
}
_pasuspender () 
{ 
    local cur prev;
    local flags='-h --help --version -s --server=';
    _init_completion -n = || return;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
    esac
}
_pbuilder-aliases () 
{ 
    local distro builder arch;
    for distro in $(ubuntu-distro-info --all; debian-distro-info --all) stable testing unstable;
    do
        for builder in pbuilder cowbuilder;
        do
            echo "$builder-$distro";
            for arch in i386 amd64 armel armhf;
            do
                echo "$builder-$distro-$arch";
            done;
        done;
    done;
    return 0
}
_pbuilder-dist () 
{ 
    local cur prev options;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    options='create update build clean login execute';
    case $prev in 
        build)
            _filedir "dsc"
        ;;
        *)
            COMPREPLY=($( compgen -W "$options" | grep "^$cur" ))
        ;;
    esac;
    return 0
}
_pci_ids () 
{ 
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur" ))
}
_pgids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pgid= )' -- "$cur" ))
}
_pids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pid= )' -- "$cur" ))
}
_pnames () 
{ 
    COMPREPLY=($( compgen -X '<defunct>' -W '$( command ps axo command= | \
        sed -e "s/ .*//" -e "s:.*/::" -e "s/:$//" -e "s/^[[(-]//" \
            -e "s/[])]$//" | sort -u )' -- "$cur" ))
}
_poff () 
{ 
    local prev cur conns;
    [ -r /etc/ppp/peers/ ] || return 0;
    COMPREPLY=();
    prev=${COMP_WORDS[COMP_CWORD-1]};
    cur=${COMP_WORDS[COMP_CWORD]};
    conns=$(\ls --color=none /etc/ppp/peers | egrep -v '(\.bak|~)$');
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '-r -d -c -a -h -v' -- $cur));
        return 0;
    fi;
    if [ $COMP_CWORD -eq 1 ] && [[ "$cur" != -* ]] || [[ "$prev" == -* ]]; then
        COMPREPLY=($(compgen -o filenames -W "$conns" $cur));
    fi;
    return 0
}
_pon () 
{ 
    local cur conns;
    [ -r /etc/ppp/peers/ ] || return 0;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    conns=$(\ls --color=none /etc/ppp/peers | egrep -v '(\.bak|~)$');
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($(compgen -o filenames -W "$conns" $cur));
    fi;
    return 0
}
_pulseaudio () 
{ 
    local cur prev words cword;
    local flags='-h --help --version --dump-conf --dump-resample-methods --cleanup-shm
                --start -k --kill --check --system= -D --daemonize= --fail= --high-priority=
                --realtime= --disallow-module-loading= --disallow-exit= --exit-idle-time=
                --scache-idle-time= --log-level= -v --log-target= --log-meta= --log-time=
                --log-backtrace= -p --dl-search-path= --resample-method= --use-pit-file=
                --no-cpu-limit= --disable-shm= -L --load= -F --file= -C -n';
    _init_completion -n = || return;
    case $cur in 
        --system=* | --daemonize=* | --fail=* | --high-priority=* | --realtime=* | --disallow-*=* | --log-meta=* | --log-time=* | --use-pid-file=* | --no-cpu-limit=* | --disable-shm=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        --log-target=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W 'auto syslog stderr file: newfile:' -- "$cur"))
        ;;
        --log-level=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W '{0..4}' -- "$cur"))
        ;;
        --dl-search-path=*)
            cur=${cur#*=};
            _filedir -d
        ;;
        --file=*)
            cur=${cur#*=};
            _filedir
        ;;
        --resample-method=*)
            cur=${cur#*=};
            comps=$(__resample_methods);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --load=*)
            cur=${cur#*=};
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --*=*)

        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
    esac;
    case $prev in 
        -D)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        -p)
            _filedir -d
        ;;
        -F)
            _filedir
        ;;
        -L)
            cur=${cur#*=};
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
    esac
}
_pygmentize () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -f)
            FORMATTERS=`pygmentize -L formatters | grep '* ' | cut -c3- | sed -e 's/,//g' -e 's/:$//'`;
            COMPREPLY=($( compgen -W '$FORMATTERS' -- "$cur" ));
            return 0
        ;;
        -l)
            LEXERS=`pygmentize -L lexers | grep '* ' | cut -c3- | sed -e 's/,//g' -e 's/:$//'`;
            COMPREPLY=($( compgen -W '$LEXERS' -- "$cur" ));
            return 0
        ;;
        -S)
            STYLES=`pygmentize -L styles | grep '* ' | cut -c3- | sed s/:$//`;
            COMPREPLY=($( compgen -W '$STYLES' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-f -l -S -L -g -O -P -F \
                                   -N -H -h -V -o' -- "$cur" ));
        return 0;
    fi
}
_quilt_comfile () 
{ 
    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -f -- "$cur" ));
    compgen -d -- "$cur" | while read d; do
        COMPREPLY=(${COMPREPLY[@]:-} "$d/");
    done
}
_quilt_completion () 
{ 
    local cur prev cmds command_matches;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    cmds='add annotate applied delete diff edit files fold fork graph \
	  grep header import init mail new next patches pop previous push refresh \
	  remove rename revert series setup shell snapshot top unapplied';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds -h" -- $cur ));
        return 0;
    fi;
    if [ ${COMP_WORDS[1]} == -h ]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    command_matches=($(compgen -W "$cmds" -- ${COMP_WORDS[1]}));
    if [ ${#command_matches[@]} -ne 1 ]; then
        return 0;
    fi;
    case ${command_matches[0]} in 
        add)
            case $prev in 
                -P)
                    COMPREPLY=($( compgen -W "$(quilt --quiltrc - applied 2>/dev/null)" -- $cur ))
                ;;
                *)
                    _quilt_comfile;
                    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W "-P -h" -- $cur ))
                ;;
            esac
        ;;
        annotate)
            case $prev in 
                -P)
                    COMPREPLY=($( compgen -W "$(quilt --quiltrc - applied 2>/dev/null)" -- $cur ))
                ;;
                *)
                    _quilt_comfile;
                    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W "-P -h" -- $cur ))
                ;;
            esac
        ;;
        applied)
            COMPREPLY=($( compgen -W "-h $(quilt --quiltrc - applied 2>/dev/null)" -- $cur ))
        ;;
        delete)
            COMPREPLY=($( compgen -W "-n -r -h --backup $(quilt --quiltrc - series)" -- $cur ))
        ;;
        diff)
            case $prev in 
                -p)
                    COMPREPLY=($( compgen -W "0 1" -- $cur ))
                ;;
                -P | --combine)
                    COMPREPLY=($( compgen -W "$(quilt --quiltrc - applied 2>/dev/null)" -- $cur ))
                ;;
                --diff | -U | -C)

                ;;
                *)
                    _filedir;
                    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W "-p -P -u -U -c -C -R -z -h --snapshot --diff --no-timestamps --no-index --combine --sort" -- $cur ))
                ;;
            esac
        ;;
        edit)
            _quilt_comfile;
            COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W "-h" -- $cur ))
        ;;
        files)
            case $prev in 
                --combine)
                    COMPREPLY=($( compgen -W "$(quilt --quiltrc - applied 2>/dev/null)" -- $cur ))
                ;;
                *)
                    COMPREPLY=($( compgen -W "-a -l -v -h --combine $(quilt --quiltrc - applied 2>/dev/null)" -- $cur ))
                ;;
            esac
        ;;
        fold)
            case $prev in 
                -p)
                    COMPREPLY=($( compgen -W "0 1" -- $cur ))
                ;;
                *)
                    _quilt_comfile;
                    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W "-p" -- $cur ))
                ;;
            esac
        ;;
        graph)
            case $prev in 
                -T)
                    COMPREPLY=($( compgen -W "ps" -- $cur ))
                ;;
                --edge-labels)
                    COMPREPLY=($( compgen -W "files" -- $cur ))
                ;;
                *)
                    COMPREPLY=($( compgen -W "-T -h --all --reduce --lines --edge-labels $(quilt --quiltrc - applied 2>/dev/null)" -- $cur ))
                ;;
            esac
        ;;
        grep)
            _longopt grep;
            COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W "-h" -- $cur ))
        ;;
        header)
            COMPREPLY=($( compgen -W "-a -e -h -r --backup --strip-diffstat --strip-trailing-whitespace $(quilt --quiltrc - series)" -- $cur ))
        ;;
        import)
            case $prev in 
                -p)
                    COMPREPLY=($( compgen -W "0 1 2 3 4 5 6 7 8 9 10" -- $cur ))
                ;;
                -P)

                ;;
                -d)
                    COMPREPLY=($( compgen -W "o a n" -- $cur ))
                ;;
                *)
                    _quilt_comfile;
                    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W "-p -P -f -d -h" -- $cur ))
                ;;
            esac
        ;;
        mail)
            COMPREPLY=($( compgen -W "-m --prefix --mbox --send --sender --from --subject --to --cc --bcc" -- $cur ))
        ;;
        next | previous)
            COMPREPLY=($( compgen -W "$(quilt --quiltrc - series)" -- $cur ))
        ;;
        patches)
            _quilt_comfile;
            COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W "-v -h" -- $cur ))
        ;;
        pop)
            COMPREPLY=($( compgen -W "-a -f -R -q -v -h $(quilt --quiltrc - applied 2>/dev/null)" -- $cur ))
        ;;
        push)
            COMPREPLY=($( compgen -W "-a -f -q -v -h --leave-rejects --interactive --color $(quilt --quiltrc - unapplied 2>/dev/null)" -- $cur ))
        ;;
        refresh)
            case $prev in 
                -p)
                    COMPREPLY=($( compgen -W "0 1" -- $cur ))
                ;;
                -U | -C)

                ;;
                *)
                    COMPREPLY=($( compgen -W "-p -u -U -c -C -f -h $(quilt --quiltrc - applied 2>/dev/null) --no-timestamps --no-index --diffstat --sort --backup --strip-trailing-whitespace" -- $cur ))
                ;;
            esac
        ;;
        remove | revert)
            case $prev in 
                -P)
                    COMPREPLY=($( compgen -W "$(quilt --quiltrc - applied 2>/dev/null)" -- $cur ))
                ;;
                *)
                    _quilt_comfile;
                    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W "-P -h" -- $cur ))
                ;;
            esac
        ;;
        rename)
            case $prev in 
                -P)
                    COMPREPLY=($( compgen -W "$(quilt --quiltrc - series)" -- $cur ))
                ;;
                *)
                    COMPREPLY=($( compgen -W "-P -h" -- $cur ))
                ;;
            esac
        ;;
        series)
            COMPREPLY=($( compgen -W "-v -h" -- $cur ))
        ;;
        setup)
            case $prev in 
                -d)
                    _filedir -d
                ;;
                *)
                    _quilt_comfile;
                    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W "-d -v -h" -- $cur ))
                ;;
            esac
        ;;
        snapshot)
            COMPREPLY=($( compgen -W "-d -h" -- $cur ))
        ;;
        unapplied)
            COMPREPLY=($( compgen -W "-h $(quilt --quiltrc - series)" -- $cur ))
        ;;
        fork | new | top | upgrade)

        ;;
    esac;
    return 0
}
_quote_readline_by_ref () 
{ 
    if [ -z "$1" ]; then
        printf -v $2 %s "$1";
    else
        if [[ $1 == \'* ]]; then
            printf -v $2 %s "${1:1}";
        else
            if [[ $1 == ~* ]]; then
                printf -v $2 ~%q "${1:1}";
            else
                printf -v $2 %q "$1";
            fi;
        fi;
    fi;
    [[ ${!2} == *\\* ]] && printf -v $2 %s "${1//\\\\/\\}";
    [[ ${!2} == \$* ]] && eval $2=${!2}
}
_rake () 
{ 
    local cur prev rakef i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    rakef="Rakefile";
    if [[ "$prev" == "-f" ]]; then
        _filedir;
        return 0;
    fi;
    if [[ "$cur" == *=* ]]; then
        prev=${cur/=*/};
        cur=${cur/*=/};
        if [[ "$prev" == "--rakefile=" ]]; then
            _filedir -o nospace;
            return 0;
        fi;
    fi;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-n -H -I -N -P -q -f\
            -r -s -T -t -h -v -V\
            --dry-run --help '--libdir=' --nosearch --prereqs --quiet\
            '--rakefile=' '--require=' --silent --tasks --trace --usage\
            --verbose --version'            -- $cur ));
    else
        for ((i=0; i < ${#COMP_WORDS[@]}; i++))
        do
            case "${COMP_WORDS[i]}" in 
                -f)
                    eval rakef=${COMP_WORDS[i+1]};
                    break
                ;;
                --rakefile=* | --rakefile\=*)
                    eval rakef=${COMP_WORDS[i]/*=/};
                    break
                ;;
            esac;
        done;
        [ ! -f $rakef ] && return 0;
        _get_comp_words_by_ref -n : cur;
        more_recent=`ls -1t .rake_tasks~ $rafefile */*/*.rake 2>/dev/null | head -n 1`;
        if [ "$more_recent" != ".rake_tasks~" ]; then
            rake -T | awk '{print($2)}' > .rake_tasks~;
        fi;
        tasks=$(cat .rake_tasks~);
        COMPREPLY=($(compgen -W "$tasks" -- "$cur"));
        __ltrim_colon_completions "$cur";
    fi
}
_realcommand () 
{ 
    type -P "$1" > /dev/null && { 
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")";
        else
            if type -p greadlink > /dev/null; then
                greadlink -f "$(type -P "$1")";
            else
                if type -p readlink > /dev/null; then
                    readlink -f "$(type -P "$1")";
                else
                    type -P "$1";
                fi;
            fi;
        fi
    }
}
_reload_bindings () 
{ 
    GLOF2_B="$(tput $GLOF2_k)";
    LOCF2_B="$(tput $LOCF2_k)";
    eval "bind -x '\"$GLOF2_B\": _b_edit_glo'";
    eval "bind -x '\"$LOCF2_B\": _b_edit_loc'";
    bind -x '"\C-p": _b_perltoggle';
    bind -x '"\C-n": _b_reresource';
    bind -x '"\C-o": _b_commit';
    bind -x '"\C-f": _b_flushme';
    bind -x '"\C-e": _b_poweroff';
    bind -x '"\C-a": _ctrl_a_handler';
    bind -x '"\C-l": clear';
    bind -x '"\C-k": { clear; /gxbase/tools/filters/dirs-short; }';
    bind -x '"[1;3A": cd ..'
}
_reload_bindings_f1 () 
{ 
    bind -x '"'$(tput kf1)'": _b_showhlp_page;_b_showhlp_page_text';
    bind -x '"'$(tput kf2)'": _b_showkeyhelp_page_'
}
_rl_enabled () 
{ 
    [[ "$( bind -v )" = *$1+([[:space:]])on* ]]
}
_root_command () 
{ 
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local root_command=$1;
    _command
}
_schroot () 
{ 
    local cur prev options;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    options=$(schroot --help | sed 's/\(^\|[[:space:]]\)[^[:space:]-][^[:space:]]*//g');
    if [ "$prev" = "-c" ] || [ "$prev" = "--chroot" ]; then
        COMPREPLY=($(compgen -W "$(schroot -a -l)" -- $cur));
        __ltrim_colon_completions "$cur";
    else
        COMPREPLY=($(compgen -W "$options" -- $cur));
    fi;
    return 0
}
_service () 
{ 
    local cur prev words cword;
    _init_completion || return;
    [[ $cword -gt 2 ]] && return 0;
    if [[ $cword -eq 1 && $prev == ?(*/)service ]]; then
        _services;
        [[ -e /etc/mandrake-release ]] && _xinetd_services;
    else
        local sysvdirs;
        _sysvdirs;
        COMPREPLY=($( compgen -W '`sed -e "y/|/ /" \
            -ne "s/^.*\(U\|msg_u\)sage.*{\(.*\)}.*$/\2/p" \
            ${sysvdirs[0]}/${prev##*/} 2>/dev/null` start stop' -- "$cur" ));
    fi
}
_services () 
{ 
    local sysvdirs;
    _sysvdirs;
    local restore_nullglob=$(shopt -p nullglob);
    shopt -s nullglob;
    COMPREPLY=($( printf '%s\n' ${sysvdirs[0]}/!($_backup_glob|functions) ));
    $restore_nullglob;
    COMPREPLY+=($( systemctl list-units --full --all 2>/dev/null |         awk '$1 ~ /\.service$/ { sub("\\.service$", "", $1); print $1 }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]#${sysvdirs[0]}/}' -- "$cur" ))
}
_setup_bvars () 
{ 
    if [[ $UID -lt 1000 ]]; then
        GLOF2="F2";
        LOCF2="Ctrl+F2";
        GLOF2_k="kf2";
        LOCF2_k="kf14";
    else
        GLOF2="Ctrl+F2";
        LOCF2="F2";
        GLOF2_k="kf14";
        LOCF2_k="kf2";
    fi
}
_shells () 
{ 
    local shell rest;
    while read -r shell rest; do
        [[ $shell == /* && $shell == "$cur"* ]] && COMPREPLY+=($shell);
    done 2> /dev/null < /etc/shells
}
_signals () 
{ 
    local -a sigs=($( compgen -P "$1" -A signal "SIG${cur#$1}" ));
    COMPREPLY+=("${sigs[@]/#${1}SIG/${1}}")
}
_split_longopt () 
{ 
    if [[ "$cur" == --?*=* ]]; then
        prev="${cur%%?(\\)=*}";
        cur="${cur#*=}";
        return 0;
    fi;
    return 1
}
_subdirectories () 
{ 
    COMPREPLY=($( cd $1 && compgen -d -- "$cur" ))
}
_svn () 
{ 
    local cur cmds cmdOpts pOpts mOpts rOpts qOpts nOpts optsParam opt;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='add blame annotate praise cat changelist cl checkout co cleanup';
    cmds="$cmds commit ci copy cp delete remove rm diff export help import";
    cmds="$cmds info list ls lock log merge mergeinfo mkdir move mv rename";
    cmds="$cmds patch propdel pdel propedit pedit propget pget proplist";
    cmds="$cmds plist propset pset relocate resolve resolved revert status";
    cmds="$cmds  switch unlock update upgrade";
    local helpOpts='--help -h';
    local specOpts="--version $helpOpts";
    optsParam="-r|--revision|--username|--password|--targets";
    optsParam="$optsParam|-x|--extensions|-m|--message|-F|--file";
    optsParam="$optsParam|--encoding|--diff-cmd|--diff3-cmd|--editor-cmd";
    optsParam="$optsParam|--old|--new|--config-dir|--config-option";
    optsParam="$optsParam|--native-eol|-l|--limit|-c|--change";
    optsParam="$optsParam|--depth|--set-depth|--with-revprop";
    optsParam="$optsParam|--cl|--changelist|--accept|--show-revs";
    local svnProps revProps allProps psCmds propCmds;
    svnProps="svn:keywords svn:executable svn:needs-lock svn:externals
	          svn:ignore svn:eol-style svn:mime-type $SVN_BASH_FILE_PROPS";
    revProps="svn:author svn:log svn:date $SVN_BASH_REV_PROPS";
    allProps=($svnProps $revProps);
    psCmds='propset|pset|ps';
    propCmds="$psCmds|propget|pget|pg|propedit|pedit|pe|propdel|pdel|pd";
    local urlSchemas='file:/// http:// https:// svn:// svn+ssh://';
    local cmd= isPropCmd= isPsCmd= isHelpCmd= nExpectArgs= isCur= i=0;
    local prev= help= prop= val= isRevProp= last='none' nargs=0 stat=;
    local options= hasRevPropOpt= hasRevisionOpt= hasRelocateOpt=;
    local acceptOpt= URL= hasReintegrateOpt=;
    for opt in "${COMP_WORDS[@]}";
    do
        [[ -n $isCur ]] && stat=$last;
        isCur=;
        [[ $i -eq $COMP_CWORD ]] && isCur=1;
        let i++;
        [ $last = 'none' ] && { 
            last='first';
            continue
        };
        if [[ $prev == @($optsParam) ]]; then
            [[ $prev = '--accept' ]] && acceptOpt=$opt;
            prev='';
            last='skip';
            continue;
        fi;
        if [[ $prev == @(<|>|>>|[12]>|[12]>>) ]]; then
            prev='';
            last='skip';
            continue;
        fi;
        prev=$opt;
        if [[ ! -n $cmd && -n $opt && ( $opt != -* || $opt == @(${specOpts// /|}) ) ]]; then
            cmd=$opt;
            [[ $cmd == @($propCmds) ]] && isPropCmd=1;
            [[ $cmd == @($psCmds) ]] && isPsCmd=1;
            [[ $cmd == @(${helpOpts// /|}) ]] && cmd='help';
            [[ $cmd = 'help' ]] && isHelpCmd=1;
            if [[ -n $isHelpCmd && -n $cmd && $cmd != 'help' && ! -n $help ]]; then
                help=$cmd;
                cmd='help';
            fi;
            last='cmd';
            continue;
        fi;
        if [[ -n $isHelpCmd && ! -n $help && -n $opt && $opt != -* ]]; then
            help=$opt;
            last='help';
            continue;
        fi;
        if [[ -n $isPropCmd && ! -n $prop && -n $opt && $opt != -* ]]; then
            prop=$opt;
            [[ $prop == @(${revProps// /|}) ]] && isRevProp=1;
            last='prop';
            continue;
        fi;
        if [[ -n $isPsCmd && -n $prop && ! -n $val && $opt != -* ]]; then
            val=$opt;
            last='val';
            continue;
        fi;
        if [[ $last != 'onlyarg' ]]; then
            case $opt in 
                -r | --revision | --revision=*)
                    hasRevisionOpt=1
                ;;
                --revprop)
                    hasRevPropOpt=1;
                    allProps=($revProps);
                    nExpectArgs=1
                ;;
                -h | --help)
                    isHelpCmd=1
                ;;
                -F | --file)
                    val='-F'
                ;;
                --relocate)
                    hasRelocateOpt=1
                ;;
                --reintegrate)
                    hasReintegrateOpt=1
                ;;
            esac;
            if [[ $opt = '--' && ! -n $isCur ]]; then
                last='onlyarg';
                continue;
            fi;
            if [[ $opt == -* ]]; then
                [[ ! -n $isCur ]] && options="$options $opt ";
                last='opt';
                continue;
            fi;
        else
            let nargs++;
            continue;
        fi;
        if [[ $cmd = 'merge' && ! -n $URL ]]; then
            URL=$opt;
        fi;
        last='arg';
        let nargs++;
    done;
    [[ -n $stat ]] || stat=$last;
    if [[ ! -n $cmd || $stat = 'cmd' ]]; then
        COMPREPLY=($( compgen -W "$cmds $specOpts" -- $cur ));
        return 0;
    fi;
    if [[ $stat = 'help' || ( -n $isHelpCmd && ! -n $help ) ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    if [[ $cmd == @(co|checkout|ls|list) && $stat = 'arg' && $SVN_BASH_COMPL_EXT == *urls* ]]; then
        if [[ $cur == file:* ]]; then
            local where=${cur/file:/};
            COMPREPLY=($(compgen -d -S '/' -X '*/.*' -- $where ));
            return;
        else
            if [[ $cur == *:* ]]; then
                local urls= file=;
                for file in ~/.subversion/auth/svn.simple/*;
                do
                    if [ -r $file ]; then
                        local url=$(_svn_read_hashfile svn:realmstring < $file);
                        url=${url/*</};
                        url=${url/>*/};
                        urls="$urls $url";
                    fi;
                done;
                local prefix=${cur%:*} suffix=${cur#*:} c= choices=;
                for c in $urls;
                do
                    [[ $c == $prefix:* ]] && choices="$choices ${c#*:}";
                done;
                COMPREPLY=($(compgen -W "$choices" -- $suffix ));
                return;
            else
                COMPREPLY=($(compgen -W "$urlSchemas" -- $cur));
                return;
            fi;
        fi;
    fi;
    if [[ $cmd = 'merge' || $cmd = 'mergeinfo' ]]; then
        local here=$(_svn_info URL);
        if [[ ! -n $URL && $stat = 'arg' ]]; then
            if [[ "$here" == */branches/* ]]; then
                COMPREPLY=($(compgen -W ${here/\/branches\/*/\/trunk} -- $cur ));
                return 0;
            else
                if [[ "$here" == */trunk* ]]; then
                    COMPREPLY=($(compgen -W ${here/\/trunk*/\/branches\/} -- $cur ));
                    return 0;
                else
                    COMPREPLY=($(compgen -W $(_svn_info Root) -- $cur ));
                    return 0;
                fi;
            fi;
        else
            if [[ $URL == */branches/* && $here == */trunk* && ! -n $hasReintegrateOpt && $cur = '' && $stat = 'arg' ]]; then
                COMPREPLY=($(compgen -W '--reintegrate' -- $cur ));
                return 0;
            fi;
        fi;
    fi;
    if [[ $stat = 'skip' ]]; then
        local previous=${COMP_WORDS[COMP_CWORD-1]};
        local values= dirs= beep= exes=;
        [[ $previous = '--config-dir' ]] && dirs=1;
        [[ $previous = --*-cmd ]] && exes=1;
        [[ $previous = '--native-eol' ]] && values='LF CR CRLF';
        [[ $previous = '--limit' ]] && values='0 1 2 3 4 5 6 7 8 9';
        [[ $previous = '--revision' || $previous = '-r' ]] && values='HEAD BASE PREV COMMITTED 0 {';
        [[ $previous = '--encoding' ]] && values="latin1 utf8 $SVN_BASH_ENCODINGS";
        [[ $previous = '--extensions' || $previous = '-x' ]] && values="--unified --ignore-space-change 		   --ignore-all-space --ignore-eol-style --show-c-functions";
        [[ $previous = '--depth' ]] && values='empty files immediates infinity';
        [[ $previous = '--set-depth' ]] && values='empty exclude files immediates infinity';
        [[ $previous = '--accept' ]] && { 
            if [[ $cmd = 'resolve' ]]; then
                values='base working mine-full theirs-full';
            else
                values="postpone base mine-full theirs-full edit launch 			mine-conflict theirs-conflict";
            fi
        };
        [[ $previous = '--show-revs' ]] && values='merged eligible';
        if [[ $previous = '--username' ]]; then
            values="$SVN_BASH_USERNAME";
            if [[ $SVN_BASH_COMPL_EXT == *username* ]]; then
                local file=;
                for file in ~/.subversion/auth/svn.simple/*;
                do
                    if [ -r $file ]; then
                        values="$values $(_svn_read_hashfile username < $file)";
                    fi;
                done;
            fi;
            [[ ! -n "$values" ]] && beep=1;
        fi;
        [[ $previous = '--password' ]] && beep=1;
        [[ -n $values ]] && COMPREPLY=($( compgen -W "$values" -- $cur ));
        [[ -n $dirs ]] && COMPREPLY=($( compgen -o dirnames -- $cur ));
        [[ -n $exes ]] && COMPREPLY=($( compgen -c -- $cur ));
        [[ -n $beep ]] && { 
            echo -en "\a";
            COMPREPLY=('')
        };
        return 0;
    fi;
    if [[ -n $isPropCmd && ( ! -n $prop || $stat = 'prop' ) && $cur != -* ]]; then
        local choices=;
        if [[ $cur == *:* ]]; then
            local prefix=${cur%:*} suffix=${cur#*:} c=;
            for c in ${allProps[@]};
            do
                [[ $c == $prefix:* ]] && choices="$choices ${c#*:}";
            done;
            cur=$suffix;
        else
            COMPREPLY=($( compgen -W "${allProps[*]}" -- $cur ));
            [ ${#COMPREPLY[@]} -eq 1 ] && return 0;
            local seen= n=0 last= c=;
            for c in ${allProps[@]%:*};
            do
                if [[ $c == $cur* && ( ! -n $seen || $c != @($seen) ) ]]; then
                    let n++;
                    last=$c;
                    choices="$choices $c:";
                    if [[ -n $seen ]]; then
                        seen="$seen|$c*";
                    else
                        seen="$c*";
                    fi;
                fi;
            done;
            [[ $n -eq 1 ]] && choices="$last:1 $last:2";
        fi;
        COMPREPLY=($( compgen -W "$choices" -- $cur ));
        return 0;
    fi;
    if [[ -n $isRevProp && ! -n $hasRevPropOpt ]]; then
        COMPREPLY=($( compgen -W '--revprop' -- $cur ));
        return 0;
    fi;
    if [[ -n $isRevProp && -n $hasRevPropOpt && ! -n $hasRevisionOpt ]]; then
        COMPREPLY=($( compgen -W '--revision' -- $cur ));
        return 0;
    fi;
    if [[ -n $isPsCmd && -n $prop && ( ! -n $val || $stat = 'val' ) ]]; then
        local values="\' --file";
        case $prop in 
            svn:keywords)
                values="Id Rev URL Date Author Header \' $SVN_BASH_KEYWORDS"
            ;;
            svn:executable | svn:needs-lock)
                values='\\*'
            ;;
            svn:eol-style)
                values='native LF CR CRLF'
            ;;
            svn:mime-type)
                values="text/ text/plain text/html text/xml text/rtf
                       image/ image/png image/gif image/jpeg image/tiff
                       audio/ audio/midi audio/mpeg
                       video/ video/mpeg video/mp4
                       application/ application/octet-stream
                       $SVN_BASH_MIME_TYPE"
            ;;
        esac;
        COMPREPLY=($( compgen -W "$values" -- $cur ));
        [[ -n ${COMPREPLY} ]] && return 0;
    fi;
    case $cmd in 
        merge)
            nExpectArgs=3
        ;;
        mergeinfo)
            nExpectArgs=1
        ;;
        copy | cp | move | mv | rename | ren | export | import)
            nExpectArgs=2
        ;;
        switch | sw)
            [[ ! -n $hasRelocateOpt ]] && nExpectArgs=2
        ;;
        help | h)
            nExpectArgs=0
        ;;
        --version)
            nExpectArgs=0
        ;;
    esac;
    if [[ -n $nExpectArgs && $nargs -gt $nExpectArgs ]]; then
        echo -en "\a";
        COMPREPLY=('');
        return 0;
    fi;
    if [[ $cur != -* || $stat = 'onlyarg' ]]; then
        if [[ $SVN_BASH_COMPL_EXT == *svnstatus* ]]; then
            local status='svn status --non-interactive';
            [[ $SVN_BASH_COMPL_EXT == *recurse* ]] || status="$status --non-recursive";
            [[ $SVN_BASH_COMPL_EXT == *externals* ]] || status="$status --ignore-externals";
            local cs= files=;
            [[ -n $cur ]] && cs=$cur*;
            case $cmd in 
                st*)
                    files=$cur*
                ;;
                ci | commit | revert | di*)
                    files=$($status $cs| _svn_grcut '@([MADR!]*| M*|_M*)')
                ;;
                add)
                    files=$($status $cs| _svn_grcut '\?*')
                ;;
                unlock)
                    files=$($status $cs| _svn_grcut '@(??L*|?????[KOTB]*)')
                ;;
                resolve*)
                    files=$($status $cs| _svn_grcut '@(?C*|C*)')
                ;;
                praise | blame | ann*)
                    files=$( _svn_lls all $cur* )
                ;;
                p*)
                    if [[ $cmd == @($propCmds) && $prop == @(svn:ignore|svn:externals) ]]; then
                        files=$( _svn_lls dir . $cur* );
                    else
                        files="$( _svn_lls all $cur* )
                                   $($status $cs | _svn_grcut 'A*' )";
                    fi
                ;;
                info)
                    files="$( _svn_lls all $cur* )
                               $($status $cs | _svn_grcut 'A*' )"
                ;;
                remove | rm | del* | move | mv | rename)
                    files=$( _svn_lls all $cur* )
                ;;
                mkdir)
                    files=$( _svn_lls dir $cur* )
                ;;
                log | lock | up* | cl* | switch)
                    files=$( _svn_lls all $cur* )
                ;;
                merge)
                    files=$( _svn_lls all $cur* )
                ;;
                ls | list)
                    files=$( _svn_lls all $cur* )
                ;;
                *)
                    local fallback=1
                ;;
            esac;
            if [[ $SVN_BASH_COMPL_EXT != *recurse* ]]; then
                files="$files $( _svn_lls dir $cur* )";
            fi;
            if [[ -n $files ]]; then
                COMPREPLY=($( compgen -W "$files" -- $cur ));
                [[ -n "${COMPREPLY[*]}" ]] || COMPREPLY=('');
            else
                if [[ ! -n $fallback ]]; then
                    echo -en "\a";
                    COMPREPLY=('');
                fi;
            fi;
        fi;
        return 0;
    fi;
    pOpts="--username --password --no-auth-cache --non-interactive 	       --trust-server-cert --force-interactive";
    mOpts="-m --message -F --file --encoding --force-log --with-revprop";
    rOpts="-r --revision";
    qOpts="-q --quiet";
    nOpts="-N --non-recursive --depth";
    gOpts="-g --use-merge-history";
    cOpts="--cl --changelist";
    cmdOpts=;
    case $cmd in 
        --version)
            cmdOpts="$qOpts"
        ;;
        add)
            cmdOpts="--auto-props --no-auto-props --force --targets 		         --no-ignore --parents $nOpts $qOpts $pOpts"
        ;;
        blame | annotate | ann | praise)
            cmdOpts="$rOpts $pOpts -v --verbose --incremental --xml 		         -x --extensions --force $gOpts"
        ;;
        cat)
            cmdOpts="$rOpts $pOpts"
        ;;
        changelist | cl)
            cmdOpts="--targets $pOpts $qOpts $cOpts                          -R --recursive --depth --remove"
        ;;
        checkout | co)
            cmdOpts="$rOpts $qOpts $nOpts $pOpts --ignore-externals                          --force"
        ;;
        cleanup)
            cmdOpts="--diff3-cmd $pOpts"
        ;;
        commit | ci)
            cmdOpts="$mOpts $qOpts $nOpts --targets --editor-cmd $pOpts 		         --no-unlock $cOpts --keep-changelists 		         --include-externals"
        ;;
        copy | cp)
            cmdOpts="$mOpts $rOpts $qOpts --editor-cmd $pOpts --parents 		         --ignore-externals"
        ;;
        delete | del | remove | rm)
            cmdOpts="--force $mOpts $qOpts --targets --editor-cmd $pOpts                          --keep-local"
        ;;
        diff | di)
            cmdOpts="$rOpts -x --extensions --diff-cmd --no-diff-deleted 		         $nOpts $pOpts --force --old --new --notice-ancestry 		         -c --change --summarize $cOpts --xml --git 		         --internal-diff --show-copies-as-adds 		         --ignore-properties --properties-only --no-diff-added 		         --patch-compatible"
        ;;
        export)
            cmdOpts="$rOpts $qOpts $pOpts $nOpts --force --native-eol                          --ignore-externals --ignore-keywords"
        ;;
        help | h | \?)
            cmdOpts=
        ;;
        import)
            cmdOpts="--auto-props --no-auto-props $mOpts $qOpts $nOpts 		         --no-ignore --editor-cmd $pOpts --force"
        ;;
        info)
            cmdOpts="$pOpts $rOpts --targets -R --recursive --depth                          --incremental --xml $cOpts"
        ;;
        list | ls)
            cmdOpts="$rOpts -v --verbose -R --recursive $pOpts                          --incremental --xml --depth --include-externals"
        ;;
        lock)
            cmdOpts="-m --message -F --file --encoding --force-log                          --targets --force $pOpts"
        ;;
        log)
            cmdOpts="$rOpts -v --verbose --targets $pOpts --stop-on-copy 		         --incremental --xml $qOpts -l --limit -c --change                          $gOpts --with-all-revprops --with-revprop --depth 		         --diff --diff-cmd -x --extensions --internal-diff 		         --with-no-revprops --search --search-and"
        ;;
        merge)
            cmdOpts="$rOpts $nOpts $qOpts --force --dry-run --diff3-cmd 		         $pOpts --ignore-ancestry -c --change -x --extensions                          --record-only --accept --reintegrate 		         --allow-mixed-revisions -v --verbose"
        ;;
        mergeinfo)
            cmdOpts="$rOpts $pOpts --depth --show-revs -R --recursive"
        ;;
        mkdir)
            cmdOpts="$mOpts $qOpts --editor-cmd $pOpts --parents"
        ;;
        move | mv | rename | ren)
            cmdOpts="$mOpts $rOpts $qOpts --force --editor-cmd $pOpts                          --parents --allow-mixed-revisions"
        ;;
        patch)
            cmdOpts="$qOpts $pOpts --dry-run --ignore-whitespace 			--reverse-diff --strip"
        ;;
        propdel | pdel | pd)
            cmdOpts="$qOpts -R --recursive $rOpts $pOpts $cOpts                          --depth";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop"
        ;;
        propedit | pedit | pe)
            cmdOpts="--editor-cmd $pOpts $mOpts --force";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop $rOpts"
        ;;
        propget | pget | pg)
            cmdOpts="-v --verbose -R --recursive $rOpts --strict 		         $pOpts $cOpts --depth --xml --show-inherited-props";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop"
        ;;
        proplist | plist | pl)
            cmdOpts="-v --verbose -R --recursive $rOpts --revprop $qOpts 		         $pOpts $cOpts --depth --xml --show-inherited-props"
        ;;
        propset | pset | ps)
            cmdOpts="$qOpts --targets -R --recursive 		         --encoding $pOpts --force $cOpts --depth";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop $rOpts";
            [[ -n $val ]] || cmdOpts="$cmdOpts -F --file"
        ;;
        relocate)
            cmdOpts="--ignore-externals $pOpts"
        ;;
        resolve)
            cmdOpts="--targets -R --recursive $qOpts $pOpts --accept                          --depth"
        ;;
        resolved)
            cmdOpts="--targets -R --recursive $qOpts $pOpts --depth"
        ;;
        revert)
            cmdOpts="--targets -R --recursive $qOpts $cOpts                          --depth $pOpts"
        ;;
        status | stat | st)
            cmdOpts="-u --show-updates -v --verbose $nOpts $qOpts $pOpts 		         --no-ignore --ignore-externals --incremental --xml                          $cOpts"
        ;;
        switch | sw)
            cmdOpts="--relocate $rOpts $nOpts $qOpts $pOpts --diff3-cmd                          --force --accept --ignore-externals --set-depth 		         --ignore-ancestry"
        ;;
        unlock)
            cmdOpts="--targets --force $pOpts"
        ;;
        update | up)
            cmdOpts="$rOpts $nOpts $qOpts $pOpts --diff3-cmd                          --ignore-externals --force --accept $cOpts                          --parents --editor-cmd --set-depth"
        ;;
        upgrade)
            cmdOpts="$qOpts $pOpts"
        ;;
        *)

        ;;
    esac;
    [[ "$cmd" != "--version" ]] && cmdOpts="$cmdOpts $helpOpts";
    cmdOpts="$cmdOpts --config-dir --config-option";
    if [[ $acceptOpt == @(edit|launch) ]]; then
        cmdOpts=${cmdOpts/ --non-interactive / };
    fi;
    for opt in $options;
    do
        local optBase;
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -v)
                cmdOpts=${cmdOpts/ --verbose / }
            ;;
            --verbose)
                cmdOpts=${cmdOpts/ -v / }
            ;;
            -N)
                cmdOpts=${cmdOpts/ --non-recursive / }
            ;;
            --non-recursive)
                cmdOpts=${cmdOpts/ -N / }
            ;;
            -R)
                cmdOpts=${cmdOpts/ --recursive / }
            ;;
            --recursive)
                cmdOpts=${cmdOpts/ -R / }
            ;;
            -x)
                cmdOpts=${cmdOpts/ --extensions / }
            ;;
            --extensions)
                cmdOpts=${cmdOpts/ -x / }
            ;;
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -l)
                cmdOpts=${cmdOpts/ --limit / }
            ;;
            --limit)
                cmdOpts=${cmdOpts/ -l / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -c)
                cmdOpts=${cmdOpts/ --change / }
            ;;
            --change)
                cmdOpts=${cmdOpts/ -c / }
            ;;
            --auto-props)
                cmdOpts=${cmdOpts/ --no-auto-props / }
            ;;
            --no-auto-props)
                cmdOpts=${cmdOpts/ --auto-props / }
            ;;
            -g)
                cmdOpts=${cmdOpts/ --use-merge-history / }
            ;;
            --use-merge-history)
                cmdOpts=${cmdOpts/ -g / }
            ;;
            -m | --message | -F | --file)
                cmdOpts=${cmdOpts/ --message / };
                cmdOpts=${cmdOpts/ -m / };
                cmdOpts=${cmdOpts/ --file / };
                cmdOpts=${cmdOpts/ -F / }
            ;;
        esac;
        if [ $isHelpCmd ]; then
            cmdOpts=${cmdOpts/ -h / };
            cmdOpts=${cmdOpts/ --help / };
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svn_grcut () 
{ 
    local re=$1 line= old_IFS;
    old_IFS="$IFS";
    IFS='
';
    while read -r line; do
        [[ ! -n $re || $line == $re ]] && echo "${line/????????/}";
    done;
    IFS="$old_IFS"
}
_svn_info () 
{ 
    local what=$1 line=;
    LANG=C LC_MESSAGES=C svn info --non-interactive 2> /dev/null | while read line; do
        [[ $line == *"$what: "* ]] && echo ${line#*: };
    done
}
_svn_lls () 
{ 
    local opt=$1 f=;
    shift;
    for f in "$@";
    do
        if [[ $opt == @(dir|all) && -d "$f" ]]; then
            echo "$f/";
        else
            if [[ $opt == @(file|all) ]]; then
                local dn= fn="$f";
                [[ "$f" == */* ]] && dn=${f%\/*}/ fn=${f##*\/};
                [ -f "${dn}.svn/text-base/${fn}.svn-base" ] && echo "$f";
            fi;
        fi;
    done
}
_svn_read_hashfile () 
{ 
    local tkey=$1 key= val=;
    while true; do
        read tag len;
        [ $tag = 'END' ] && break;
        [ $tag != 'K' ] && { 
            return
        };
        read -r -n $len key;
        read;
        read tag len;
        [ $tag != 'V' ] && { 
            return
        };
        read -r -n $len val;
        read;
        if [[ $key = $tkey ]]; then
            echo "$val";
            return;
        fi;
    done
}
_svnadmin () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='crashtest create deltify dump freeze help hotcopy list-dblogs \
	      list-unused-dblogs load lock lslocks lstxns pack recover rmlocks \
	      rmtxns setlog setrevprop setuuid unlock upgrade verify --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="-r|--revision|--parent-dir|--fs-type|-M|--memory-cache-size";
    optsParam="$optsParam|-F|--file";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        create)
            cmdOpts="--bdb-txn-nosync --bdb-log-keep --config-dir 		         --fs-type --pre-1.4-compatible --pre-1.5-compatible 		         --pre-1.6-compatible --compatible-version"
        ;;
        deltify)
            cmdOpts="-r --revision -q --quiet"
        ;;
        dump)
            cmdOpts="-r --revision --incremental -q --quiet --deltas 		         -M --memory-cache-size"
        ;;
        freeze)
            cmdOpts="-F --file"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        hotcopy)
            cmdOpts="--clean-logs"
        ;;
        load)
            cmdOpts="--ignore-uuid --force-uuid --parent-dir -q --quiet 		         --use-pre-commit-hook --use-post-commit-hook 		         --bypass-prop-validation -M --memory-cache-size"
        ;;
        lock | unlock)
            cmdOpts="--bypass-hooks"
        ;;
        recover)
            cmdOpts="--wait"
        ;;
        rmtxns)
            cmdOpts="-q --quiet"
        ;;
        setlog)
            cmdOpts="-r --revision --bypass-hooks"
        ;;
        setrevprop)
            cmdOpts="-r --revision --use-pre-revprop-change-hook 		         --use-post-revprop-change-hook"
        ;;
        verify)
            cmdOpts="-r --revision -q --quiet"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -F)
                cmdOpts=${cmdOpts/ --file / }
            ;;
            --file)
                cmdOpts=${cmdOpts/ -F / }
            ;;
            -M)
                cmdOpts=${cmdOpts/ --memory-cache-size / }
            ;;
            --memory-cache-size)
                cmdOpts=${cmdOpts/ --M / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svndumpfilter () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='exclude help include --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="--targets";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        exclude | include)
            cmdOpts="--drop-empty-revs --renumber-revs
		         --skip-missing-merge-sources --targets
		         --preserve-revprops --quiet"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnlook () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='author cat changed date diff dirs-changed help history info \
	      lock log propget proplist tree uuid youngest --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="-r|--revision|-t|--transaction|-l|--limit|-x|--extensions";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        author)
            cmdOpts="-r --revision -t --transaction"
        ;;
        cat)
            cmdOpts="-r --revision -t --transaction"
        ;;
        changed)
            cmdOpts="-r --revision -t --transaction --copy-info"
        ;;
        date)
            cmdOpts="-r --revision -t --transaction"
        ;;
        diff)
            cmdOpts="-r --revision -t --transaction --diff-copy-from 		         --no-diff-added --no-diff-deleted -x --extensions"
        ;;
        dirs-changed)
            cmdOpts="-r --revision -t --transaction"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        history)
            cmdOpts="-r --revision -l --limit --show-ids"
        ;;
        info)
            cmdOpts="-r --revision -t --transaction"
        ;;
        lock)
            cmdOpts=
        ;;
        log)
            cmdOpts="-r --revision -t --transaction"
        ;;
        propget | pget | pg)
            cmdOpts="-r --revision -t --transaction --revprop"
        ;;
        proplist | plist | pl)
            cmdOpts="-r --revision -t --transaction --revprop -v --verbose --xml"
        ;;
        tree)
            cmdOpts="-r --revision -t --transaction --full-paths -N --non-recursive --show-ids"
        ;;
        uuid)
            cmdOpts=
        ;;
        youngest)
            cmdOpts=
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -N)
                cmdOpts=${cmdOpts/ --non-recursive / }
            ;;
            --non-recursive)
                cmdOpts=${cmdOpts/ -N / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -l)
                cmdOpts=${cmdOpts/ --limit / }
            ;;
            --limit)
                cmdOpts=${cmdOpts/ -l / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -t)
                cmdOpts=${cmdOpts/ --transaction / }
            ;;
            --transaction)
                cmdOpts=${cmdOpts/ -t / }
            ;;
            -v)
                cmdOpts=${cmdOpts/ --verbose / }
            ;;
            --verbose)
                cmdOpts=${cmdOpts/ -v / }
            ;;
            -x)
                cmdOpts=${cmdOpts/ --extensions / }
            ;;
            --extensions)
                cmdOpts=${cmdOpts/ -x / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnsync () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='copy-revprops help info initialize synchronize --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="--config-dir|--config-option|--source-username|--source-password";
    optsParam="$optsParam|--sync-username|--sync-password";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        copy-revprops | initialize | init | synchronize | sync)
            cmdOpts="--non-interactive --no-auth-cache --trust-server-cert 		         --source-username --source-password --sync-username 		         --sync-password --config-dir --config-option -q --quiet"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        info)
            cmdOpts="--non-interactive --no-auth-cache --trust-server-cert 		         --source-username --source-password --sync-username 		         --sync-password --config-dir --config-option"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnversion () 
{ 
    local cmdOpts=" -n --no-newline -c --committed -h --help --version ";
    local cur=${COMP_WORDS[COMP_CWORD]};
    COMPREPLY=();
    local options= wcpath= trailurl= last='none' stat= opt= i=-1 isCur=;
    for opt in ${COMP_WORDS[@]};
    do
        [[ $i -eq $COMP_CWORD ]] && stat=$last;
        let i++;
        isCur=;
        [[ $i -eq $COMP_CWORD ]] && isCur=1;
        if [ $last = 'none' ]; then
            last='first';
            continue;
        fi;
        if [[ $last != 'arg' && $opt == -* ]]; then
            if [[ $opt = '--' && ! -n $isCur ]]; then
                last='arg';
            else
                options="$options $opt ";
                last='opt';
            fi;
            continue;
        fi;
        if [[ $opt != -* ]]; then
            last='arg';
            if [[ ! -n $wcpath ]]; then
                wcpath=$opt;
            else
                if [[ ! -n $trailurl ]]; then
                    trailurl=$opt;
                fi;
            fi;
        fi;
    done;
    [[ -n $stat ]] || stat=$last;
    if [[ $cur != -* || $stat = 'arg' ]]; then
        [[ -n $wcpath && -n $trailurl ]] && COMPREPLY=('');
        return 0;
    fi;
    for opt in $options;
    do
        cmdOpts=${cmdOpts/ $opt / };
        case $opt in 
            -n)
                cmdOpts=${cmdOpts/ --no-newline / }
            ;;
            --no-newline)
                cmdOpts=${cmdOpts/ -n / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -c)
                cmdOpts=${cmdOpts/ --committed / }
            ;;
            --committed)
                cmdOpts=${cmdOpts/ -c / }
            ;;
        esac;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_sysvdirs () 
{ 
    sysvdirs=();
    [[ -d /etc/rc.d/init.d ]] && sysvdirs+=(/etc/rc.d/init.d);
    [[ -d /etc/init.d ]] && sysvdirs+=(/etc/init.d);
    [[ -f /etc/slackware-version ]] && sysvdirs=(/etc/rc.d)
}
_terms () 
{ 
    COMPREPLY+=($( compgen -W         "$( sed -ne 's/^\([^[:space:]#|]\{2,\}\)|.*/\1/p' /etc/termcap             2>/dev/null )" -- "$cur" ));
    COMPREPLY+=($( compgen -W "$( { toe -a 2>/dev/null || toe 2>/dev/null; }         | awk '{ print $1 }' | sort -u )" -- "$cur" ))
}
_tilde () 
{ 
    local result=0;
    if [[ $1 == \~* && $1 != */* ]]; then
        COMPREPLY=($( compgen -P '~' -u "${1#\~}" ));
        result=${#COMPREPLY[@]};
        [[ $result -gt 0 ]] && compopt -o filenames 2> /dev/null;
    fi;
    return $result
}
_ufw () 
{ 
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W "$(_ufw_commands)" $cur ));
    else
        if [ $COMP_CWORD -eq 2 ]; then
            case "$prev" in 
                app)
                    COMPREPLY=($( compgen -W "$(_ufw_app_commands)" $cur ))
                ;;
                status)
                    COMPREPLY=($( compgen -W "$(_ufw_status_commands)" $cur ))
                ;;
                delete)
                    COMPREPLY=($( compgen -W "$(_ufw_rule_commands)" $cur ))
                ;;
                logging)
                    COMPREPLY=($( compgen -W "$(_ufw_logging_commands)" $cur ))
                ;;
                show)
                    COMPREPLY=($( compgen -W "$(_ufw_show_commands)" $cur ))
                ;;
                default)
                    COMPREPLY=($( compgen -W "$(_ufw_default_commands)" $cur ))
                ;;
            esac;
        fi;
    fi
}
_ufw_app_commands () 
{ 
    ufw --help | sed -e '1,/^Application profile commands:/d' -e '/^ [^ ]/!d' -e 's/[ \t]\+app[ \t]\+\([a-z|]\+\)[ \t]\+.*/\1/g'
}
_ufw_commands () 
{ 
    commands=$(ufw --help | sed -e '1,/^Commands:/d' -e '/^Application profile commands:/Q' -e 's/^[ \t]\+\([a-z|]\+\)[ \t]\+.*/\1/g' -e 's/|/ /g' | uniq);
    echo "$commands app"
}
_ufw_default_commands () 
{ 
    echo "allow deny reject"
}
_ufw_logging_commands () 
{ 
    echo "off on low medium high full"
}
_ufw_rule_commands () 
{ 
    echo "`_ufw_default_commands` limit"
}
_ufw_show_commands () 
{ 
    echo "raw"
}
_ufw_status_commands () 
{ 
    echo "numbered verbose"
}
_uids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($( compgen -W '$( getent passwd | cut -d: -f3 )' -- "$cur" ));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/passwd )' -- "$cur" ));
        fi;
    fi
}
_unar () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -o | -output-directory)
            _filedir -d;
            return 0
        ;;
        -p | -password)
            return 0
        ;;
        -e | -encoding | -E | -password-encoding)
            COMPREPLY=($( compgen -W                     "$(unar -e list | sed -n 's/, //g;s/[()]//g;s/^  \* //p')"                     -- "$cur" ));
            return 0
        ;;
        -f | -forks)
            COMPREPLY=($( compgen -W 'visible hidden skip' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-o -output-directory -f -force-overwrite \
                -r -force-rename -s -force-skip -d -force-directory -D \
                -no-directory -p -password -e -encoding -E -password-encoding \
                -i -indexes -nr -no-recursion -t -copy-time -f -forks -h -help'                 -- "$cur" ));
    else
        _filedir '@(rar|zip|tar|gz|bz2|cab|7z|msi|exe|iso|lzma|xz|zipx|lzh|cpio|rpm|lha|z|tbz|tbz2|xar|pit|arc|nds|zoo|lz|deb)';
    fi
}
_unp () 
{ 
    local cur;
    COMPREPLY=();
    cur="$(_get_cword)";
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W '-u' -- "$cur" ))
        ;;
        *)
            _filedir '@(zip|ZIP|jar|JAR|exe|EXE|pk3|war|wsz|ear|zargo|xpi|Z|gz|tgz|Gz|dz|lha|LHa|lhz|deb|ar|bz2|tbz2|rpm|shar|rar|arj|cab|ace|tnef|uu|mime|hqx|sea|zoo|pmd|cpio|afio|lzop|tar|lz|xz|lzma|7z)'
        ;;
    esac;
    return 0
}
_update_initramfs () 
{ 
    local cur prev valid_options;
    cur=$(_get_cword);
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [[ "$prev" == '-k' ]]; then
        _kernel_versions;
        COMPREPLY=($( compgen -W '${COMPREPLY[@]} all' -- "$cur" ));
        return;
    fi;
    valid_options=$( update-initramfs -h 2>&1 | 		sed -e '/^ -/!d;s/^ \(-\w\+\).*/\1/' );
    COMPREPLY=($( compgen -W "$valid_options" -- $cur ))
}
_upvar () 
{ 
    if unset -v "$1"; then
        if (( $# == 2 )); then
            eval $1=\"\$2\";
        else
            eval $1=\(\"\${@:2}\"\);
        fi;
    fi
}
_upvars () 
{ 
    if ! (( $# )); then
        echo "${FUNCNAME[0]}: usage: ${FUNCNAME[0]} [-v varname" "value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (( $# )); do
        case $1 in 
            -a*)
                [[ -n ${1#-a} ]] || { 
                    echo "bash: ${FUNCNAME[0]}: \`$1': missing" "number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" &> /dev/null || { 
                    echo "bash:" "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && shift $((${1#-a} + 2)) || { 
                    echo "bash: ${FUNCNAME[0]}:" "\`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && shift 3 || { 
                    echo "bash: ${FUNCNAME[0]}: $1: missing" "argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash: ${FUNCNAME[0]}: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
_usb_ids () 
{ 
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lsusb | awk '{print $6}' )" -- "$cur" ))
}
_user_at_host () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur";
    else
        COMPREPLY=($( compgen -u -- "$cur" ));
    fi;
    return 0
}
_usergroup () 
{ 
    if [[ $cur = *\\\\* || $cur = *:*:* ]]; then
        return;
    else
        if [[ $cur = *\\:* ]]; then
            local prefix;
            prefix=${cur%%*([^:])};
            prefix=${prefix//\\};
            local mycur="${cur#*[:]}";
            if [[ $1 == -u ]]; then
                _allowed_groups "$mycur";
            else
                local IFS='
';
                COMPREPLY=($( compgen -g -- "$mycur" ));
            fi;
            COMPREPLY=($( compgen -P "$prefix" -W "${COMPREPLY[@]}" ));
        else
            if [[ $cur = *:* ]]; then
                local mycur="${cur#*:}";
                if [[ $1 == -u ]]; then
                    _allowed_groups "$mycur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -g -- "$mycur" ));
                fi;
            else
                if [[ $1 == -u ]]; then
                    _allowed_users "$cur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -u -- "$cur" ));
                fi;
            fi;
        fi;
    fi
}
_userland () 
{ 
    local userland=$( uname -s );
    [[ $userland == @(Linux|GNU/*) ]] && userland=GNU;
    [[ $userland == $1 ]]
}
_valgrind () 
{ 
    local cur prev opts yesno tools choosen_tool i;
    yesno="--trace-children\= --child-silent-after-fork\= --track-fds\= --time-stamp\= --log-fd\=  --log-socket\=";
    opts="--tool\= ";
    opts+="-h --help --help-debug --version -q --quiet -v --verbose --log-file\= ";
    COMPREPLY=();
    for ((i=0; i < COMP_CWORD; i++ ))
    do
        if [[ ${COMP_WORDS[i]} == -- ]]; then
            _command_offset $((i + 1));
            return 0;
        fi;
    done;
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        if [[ ${COMP_WORDS[i]} == "--tool" ]]; then
            choosen_tool=${COMP_WORDS[i+2]};
        fi;
    done;
    case $choosen_tool in 
        'callgrind')
            opts+="--callgrind-out-file\= --dump-every-bb\= --dump-before\= --zero-before\= --dump-after\= --toggle-collect\= --separate-recs\= --separate-callers\= --fn-skip\= --fn-group< --separate-recs< --separate-callers< ";
            yesno+="--dump-instr\= --dump-line\= --compress-strings\= --compress-pos\= --combine-dumps\= --instr-atstart\= --collect-atstart\= --collect-jumps\= --separate-threads\= --skip-plt\= --simulate-cache\= --simulate-hwpref\= "
        ;;
        'cachegrind')
            opts+="--I1\= --D1\= --L2\= --cachegrind-out-file\= ";
            yesno+="--cache-sim\= --branch-sim\= "
        ;;
        'memcheck')
            yesno+="--undef-value-errors\= --track-origins\= --show-reachable\= --workaround-gcc296-bugs\= --partial-loads-ok\= ";
            opts+="--leak-check\= --leak-resolution\= --freelist-vol\= --malloc-fill\= --free-fill\= "
        ;;
        *)
            yesno+="--undef-value-errors\= --track-origins\= --show-reachable\= --workaround-gcc296-bugs\= --partial-loads-ok\= ";
            opts+="--leak-check\= --leak-resolution\= --freelist-vol\= --malloc-fill\= --free-fill\= "
        ;;
    esac;
    opts+="$yesno ";
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD - 1]}";
    if [[ "$prev" == "=" ]]; then
        prev="${COMP_WORDS[COMP_CWORD - 2]}";
    else
        if [[ "$cur" == "=" ]]; then
            cur="";
        fi;
    fi;
    if [[ "$prev" == "--tool" ]]; then
        tools="memcheck cachegrind callgrind massif helgrind lackey none drd exp-bbv exp-ptrcheck";
        COMPREPLY=($(compgen -W "$tools" -- $cur ));
        COMPREPLY+=" ";
        return 0;
    fi;
    if [[ "${yesno}" == *$prev* ]]; then
        COMPREPLY=($(compgen -W "yes no" -- $cur ));
        COMPREPLY+=" ";
        return 0;
    fi;
    case "$prev" in 
        --log-file)
            _filedir;
            return 0
        ;;
        *)

        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "$opts" -- $cur));
        return 0;
    else
        _filedir;
        return 0;
    fi
}
_variables () 
{ 
    if [[ $cur =~ ^(\$\{?)([A-Za-z0-9_]*)$ ]]; then
        [[ $cur == *{* ]] && local suffix=} || local suffix=;
        COMPREPLY+=($( compgen -P ${BASH_REMATCH[1]} -S "$suffix" -v --             "${BASH_REMATCH[2]}" ));
        return 0;
    fi;
    return 1
}
_xfunc () 
{ 
    set -- "$@";
    local srcfile=$1;
    shift;
    declare -F $1 &> /dev/null || { 
        local compdir=./completions;
        [[ $BASH_SOURCE == */* ]] && compdir="${BASH_SOURCE%/*}/completions";
        . "$compdir/$srcfile"
    };
    "$@"
}
_xinetd_services () 
{ 
    local xinetddir=/etc/xinetd.d;
    if [[ -d $xinetddir ]]; then
        local restore_nullglob=$(shopt -p nullglob);
        shopt -s nullglob;
        local -a svcs=($( printf '%s\n' $xinetddir/!($_backup_glob) ));
        $restore_nullglob;
        COMPREPLY+=($( compgen -W '${svcs[@]#$xinetddir/}' -- "$cur" ));
    fi
}
alias () 
{ 
    declare -gi AX_ALIAS_CALLS;
    if [[ $0 =~ bash ]]; then
        let AX_ALIAS_CALLS++;
    else
        builtin alias "$@";
        return $?;
    fi;
    ax.checkaliasdir && NOGLOB=0 || NOGLOB=1;
    [[ $1 == '--nolocal' ]] && { 
        NOLOC=1;
        shift
    } || NOLOC=0;
    if [[ $# -eq 1 ]]; then
        if [[ $1 =~ = ]]; then
            local NAME="${1%%=*}";
            if [[ ! $NAME =~ ' '+ ]]; then
                declare -gx LASTALIASSET=$NAME;
            else
                echo "$NAME - alias name contains illegal characters!";
                return 1;
            fi;
        else
            if [[ -n ${BASH_ALIASES[$1]} ]]; then
                builtin alias "$1";
                return $?;
            else
                if [[ -r $AX_BASE/alias/$1 ]]; then
                    echo "global version: currently offline";
                    echo "value: $(cat $AX_BASE/alias/$1)";
                    return 1;
                else
                    echo "no alias, $1, defined global or local";
                    return 1;
                fi;
            fi;
        fi;
    else
        if [[ $# -eq 0 ]]; then
            builtin alias;
            return $?;
        else
            FINALRET=0;
            for i in "$@";
            do
                if [[ $i =~ .*=.* ]]; then
                    alias "$i";
                else
                    if [[ $i == -p ]]; then
                        :;
                    else
                        builtin alias "$i";
                    fi;
                fi;
                [[ $? -ne 0 ]] && FINALRET=1;
            done;
            return $FINALRET;
        fi;
    fi;
    if [[ $NOLOC == 0 ]]; then
        builtin alias "$@";
    fi;
    if [[ $NOGLOB == 0 ]]; then
        builtin alias "$NAME" > $AX_BASE/alias/$NAME;
    fi
}
assert_exists () 
{ 
    for x in "$@";
    do
        if [[ ! -r "$x" ]]; then
            return 1;
        fi;
    done;
    return 0
}
ax.acquire () 
{ 
    return;
    declare -gA AX_ACQUISITIONS;
    for x in "$@";
    do
        [[ ${x: 0:1} == "<" ]] && [[ ${x: -1:1} == ">" ]] && BRACED=1 || BRACED=0;
        j="${x%%>}";
        i="${j##<}";
        i="${j##[0-9][0-9]}";
        if ax.contains.i AX_ACQUISITIONS "$i"; then
            return 1;
        else
            if [[ $BRACED == 1 ]]; then
                ITEMS=($(find -L $AX_BASE -iname '$i'));
                ITEM="${ITEMS[0]}";
            else
                ITEM="$x";
            fi;
        fi;
        source "$ITEM";
    done
}
ax.cache.create () 
{ 
    while true; do
        getopts rh AXOPT;
        OERR=$?;
        echo "OPTIND=$OPTIND AXOPT=$AXOPT OPTERR=$OPTERR OPTARG=$OPTARG \$?=$?";
        case $AXOPT in 
            d)
                DELETE_CACHE=1
            ;;
            h)
                echo -e "usage: $FUNCNAME [-d] [-h]\n\n\-d\tremove cache instead\n-h\tthis help text\n"
            ;;
            *)
                echo "Function: unexpected value \"$AXOPT\""
            ;;
        esac;
        [[ $OERR == 1 ]] && break;
    done;
    if [[ -r $AX_BASE/autox ]]; then
        AXBM="pre";
    else
        declare -gx AX_BASE=$(readlink -a $(dirname "$BASH_SOURCE"));
        AXBM="manually ";
    fi;
    echo "AutoX base path has been ${AXBM}configured for use in $(tput bold)$AX_BASE$(tput sgr0)";
    if [[ ! -r $AX_BASE/autox ]]; then
        echo "...but it isnt valid, Stop.";
        return 1;
    fi;
    AX_CACHE_SITE=$AX_BASE/cache/usecache;
    ((DELETE_CACHE)) && echo "Removing cache site..." || echo "Creating cache site...";
    if [[ -d $AX_CACHE_SITE ]]; then
        echo "Do you want to remove the old cache? (no undo) [y/n]:";
        while [[ $(choice -sn1; echo $REPLY) =~ ^[^yn]$ ]]; do
            echo "Please press [y] or [n]";
        done;
        if [[ $REPLY == n ]]; then
            echo "Aborted.";
            return 1;
        fi;
        if ! rm -fr "$AX_CACHE_SITE"; then
            echo "Can't remove old data, check permissions";
            return 1;
        fi;
    fi;
    if ((DELETE_CACHE)); then
        echo "All That Can Be Done Has Been Done.";
        return 0;
    fi;
    if ! mkdir -pv -p "$AX_CACHE_SITE" || ! touch "$AX_CACHE_SITE/.site_validation"; then
        echo "Failed to create/write-to new cache site, please check your permissions!";
        echo "at: $AX_CACHE_SITE";
        return 1;
    fi;
    declare -i AX_CACHE_SHA_SIZE=512;
    function _ax__generate_values () 
    { 
        eval "${PROCS[${STEPS[$2]}]}" > "$1" && (($2==$3)) && unset -f $FUNCNAME
    };
    declare -A PROCS=([value]='builtin declare' [binding]='builtin bind -psvX' [alias]='builtin alias -p' [completion]='builtin complete' [option]='shopt -p; shopt -po' [hash]='hash -l' [trap]='trap -l' [shasum]='shasum $AX_CACHE_SITE/!(shasum.act) -a $AX_CACHE_SHA_SIZE');
    declare -a STEPS=(value binding alias completion option hash trap shasum);
    declare -i PERCENT=-1 STEP=-1 LAST=${#STEPS[@]}-1;
    declare incrementer='let STEP++ "PERCENT=STEP*100/LAST"; echo -e "\E8${STEPS[$STEP]}s... ($PERCENT% completed)\E[J"; STEPF="$AX_CACHE_SITE/${STEPS[$STEP]}.act"';
    echo -e "Creating Cache...\E7";
    while [[ $STEP < $LAST ]]; do
        eval $incrementer;
        _ax__generate_values "$STEPF" $STEP $LAST;
    done
}
ax.checkaliasdir () 
{ 
    [[ -r $AX_BASE/alias/alias.id ]] || { 
        echo "error: AX_BASE not set properly, alias.id missing from alias directory!";
        return 1
    }
}
ax.config () 
{ 
    CACHELOAD=0;
    if [[ ! -v CONFIG_CACHE[initialized] ]]; then
        declare -gA CONFIG_CACHE=([initialized]="true");
    fi;
    unset RETV;
    if [[ $1 == cacheok ]]; then
        shift;
        if [[ -n ${CONFIG_CACHE[$*]} ]]; then
            RETV=${CONFIG_CACHE[$*]};
            CACHELOAD=1;
        fi;
    fi;
    declare -gix ax_config_error=0;
    if [[ -v RETV ]] || [[ -r $AX_BASE/config/autoxrc ]]; then
        if [[ -v RETV ]] || RETV=`grep "(?<=^${*}=).*$" -Po $AX_BASE/config/autoxrc`; then
            [[ $CACHELOAD == 0 ]] && CONFIG_CACHE[$*]="$RETV";
            if [[ $RETV =~ ^[0-9]+$ ]]; then
                return $RETV;
            else
                echo $RETV;
                return 1;
            fi;
        else
            CONFIG_CACHE[$*]="1";
            ax_config_error=1;
            return 1;
        fi;
    else
        mkdir --parents $AX_BASE/config;
        touch $AX_BASE/config/autoxrc;
        cat  > $AX_BASE/config/autoxrc <<-EOF
#
# autoxrc
# autox configuration
#
configuration_created=1
EOF

        if (($?)); then
            echo "WARNING: could not create configuration file!";
            tty -s && sleep 2;
        else
            echo "Configuration File Was Created: $AX_BASE/config/autoxrc";
        fi;
    fi
}
ax.config.get () 
{ 
    if ax.config.has $1; then
        VALUE="$(ax.config $1)";
        echo ${VALUE:-$?};
        return 0;
    else
        return 1;
    fi
}
ax.config.has () 
{ 
    ax.config $1 &> /dev/null;
    return $ax_config_error
}
ax.config.set () 
{ 
    if ax.config.has $1; then
        echo "replacing value: $1=$2";
        ax.config.;
    else
        echo "$1=$2" >> $AX_BASE/config/autoxrc;
    fi
}
ax.contains () 
{ 
    ITEM=$1;
    shift;
    for i in "$@";
    do
        if [[ $i == $ITEM ]]; then
            return 0;
        fi;
    done;
    return 1
}
ax.contains.i () 
{ 
    local NOT_CONTAINS=0;
    while (( $# % 2 == 0 )); do
        ITEM=$1;
        ARRAY_NAME=$2;
        shift 2;
        eval 'ARRAY_VALUES=( "${'$ARRAY_NAME'[@]}" )';
        if ax.contains $ITEM "$@"; then
            echo "$( [[ $INDEX -gt 0 ]] && echo ' ' )$INDEX";
            continue;
        fi;
        echo "$ARRAY_NAME";
        let NOT_CONTAINS++;
    done;
    return $NOT_CONTAINS
}
ax.echo () 
{ 
    case $1 in 
        on | off)
            case $1 in 
                on)
                    AX_DEBUGGING=1
                ;;
                off)
                    AX_DEBUGGING=0
                ;;
            esac;
            echo "ax.echo is now $1";
            return 0
        ;;
    esac;
    ((AX_DEBUGGING)) && echo "$@"
}
ax.flag () 
{ 
    AX_FLAGBASE=~/.config/autox/flags;
    [[ -d $AX_FLAGBASE ]] || mkdir -pv --parents $AX_FLAGBASE;
    if [[ $# -gt 2 ]]; then
        while [[ $# -gt 0 ]]; do
            A="$1";
            B="$2";
            shift 2;
            ax.flag "$A" "$B";
        done;
        return;
    else
        if [[ $# -gt 0 ]]; then
            case $1 in 
                list)
                    pushd . > /dev/null;
                    cd $AX_FLAGBASE;
                    shift;
                    eval "ls -C${*+ }${*- $*}";
                    popd > /dev/null
                ;;
                on)
                    touch $AX_FLAGBASE/$2
                ;;
                off)
                    if [[ -r $AX_FLAGBASE/$2 ]]; then
                        if ax.choice "Remove flag $(ax.file ns $2)?"; then
                            rm $AX_FLAGBASE/$2;
                        else
                            echo "Aborted.";
                        fi;
                    fi
                ;;
                *)
                    tree -A $AX_FLAGBASE
                ;;
            esac;
        fi;
    fi
}
ax.helperalias () 
{ 
    if [[ ! -v AX_HELPER_ALIASES ]]; then
        declare -gxa AX_HELPER_ALIASES=(`cat $BASH_SOURCE | grep '^ax\.[^\( ]+' -Po`);
    fi;
    if [[ $# -gt 1 ]]; then
        for item in "$@";
        do
            ax.helperalias "$item";
        done;
    else
        if [[ $# -eq 1 ]]; then
            NAME="${*%%=*}";
            OVERWRITE=NO;
            for i in "${AX_HELPER_ALIASES[@]}";
            do
                if [[ "$i" == "$NAME" ]]; then
                    echo "Warning, This ax.helper alias is being overwritten: $i";
                    OVERWRITE=YES;
                else
                    if ax.config cacheok debug_helperalias; then
                        echo "debug: ax.helper $i being set for first time ok";
                    fi;
                fi;
            done;
            builtin alias "$@";
            [[ $OVERWRITE == NO ]] && AX_HELPER_ALIASES+=($NAME);
        else
            echo -e "builtin helper aliases:\n";
            if [[ -v AX_HELPER_ALIASES ]]; then
                local -i n=0;
                for i in ${AX_HELPER_ALIASES[@]};
                do
                    echo -e "\t$i";
                    let n++;
                done;
                echo -e "\n$n alias(es).\n";
            else
                echo -e "\t<<NONE>>\n\nZero alias(es).\n";
            fi;
        fi;
    fi
}
ax.load () 
{ 
    ax.checkaliasdir || return 2;
    ALIAS_ITEMS=($(grep -P '^\s*alias \S+=' $AX_BASE/alias/* --line-number | grep '^[^:]*(?=:1)' -P -o));
    ALIAS_CACHE=$(mktemp);
    if [[ ${#ALIAS_ITEMS[@]} -gt 0 ]]; then
        cat ${ALIAS_ITEMS[@]} | sed 's/^alias/builtin alias/g' > $ALIAS_CACHE;
        source $ALIAS_CACHE;
        rm $ALIAS_CACHE;
    else
        echo "Warning: no aliases have been defined in the autox install of $AX_BASE";
    fi
}
ax.promptfactory () 
{ 
    [[ $- =~ T ]] && trap DEBUG;
    case $1 in 
        PS1)
            echo -ne "$USER@$HOSTNAME $PWD [$2]:";
            for ((i=0; i<$SHLVL; i++))
            do
                printf "$i";
            done;
            printf ":"
        ;;
        PS2)
            echo -ne "more?"
        ;;
        PS3)
            case "$2" in 
                REWRITE)
                    [[ -n $PS3_CACHE ]] && eval PS3="$PS3_CACHE"
                ;;
                *)
                    eval PS3="$2"
                ;;
            esac
        ;;
    esac
}
ax.reload () 
{ 
    if { 
        if [[ -r $AX_BASE/autox ]] && [[ -v AX_BASE ]]; then
            local AX_BASE_TEMP=$AX_BASE;
            unset AX_BASE;
            source "$AX_BASE_TEMP/autox";
        else
            echo "$FUNCNAME: warning - autox AX_BASE not set or not right, loading fresh copy...";
            source "$BASH_SOURCE";
        fi
    }; then
        if [[ -v AX_BASE ]] && [[ -d $AX_BASE/alias ]]; then
            echo "Load succeeded!";
            return 0;
        else
            echo "Load okay, but AX_BASE does not point to a proper location!!! Please check your installation files!!";
            return 1;
        fi;
    else
        echo "Failed! *check your permissions/environment/installation*";
        return 2;
    fi
}
ax.reloader.promptfactory () 
{ 
    source "$BASH_SOURCE"
}
ax.unload () 
{ 
    ax.checkaliasdir || return 2;
    for i in $AX_BASE/alias/*;
    do
        builtin unalias $(basename $i);
        ax.echo "unloading global alias $i";
    done
}
ax.updatecache () 
{ 
    true
}
ax.usage () 
{ 
    R=$?;
    cat $BASH_SOURCE | grep --color=auto -Po '(?<=USAGE:\s).*$';
    return $R
}
axbe () 
{ 
    local TARGET="$AX_BASE/lib/axbe.pl";
    if [[ -r "$TARGET" ]]; then
        perl -I$AX_BASE/lib -s "$TARGET" -- "$@";
    else
        echo "Fatal: cannot execute $TARGET, is AX_BASE set properly? (autox initialized properly?)";
    fi
}
chmog () 
{ 
    0 ]] && $FUNCNAME --help
}
clear () 
{ 
    if tput sgr0 && tput clear; then
        return 0;
    else
        if infocmp | grep --color=auto clear; then
            echo -ne "\e[2J\e[0m";
        else
            for ((i=0; i<1000; i++))
            do
                echo;
            done;
        fi;
    fi
}
cnfh () 
{ 
    CMDPFX="";
    PREFIX=${1: 0:1};
    SUFFIX=${1: 1};
    CMDNAME="";
    ORGCMD="$1";
    IFS=:;
    shift;
    AX_PX_STATUS="INIT_VARS_COMPLETE";
    for j in $PATH;
    do
        if [[ -x $j/$SUFFIX ]]; then
            CMDNAME=$j/$SUFFIX;
            break;
        fi;
    done;
    unset IFS;
    CMDSUFF="";
    GI=0;
    if ! [[ $(compgen -A function) =~ prefixer.warning ]]; then
        function prefixer.warning () 
        { 
            if ax.config.has prefixer_warnings && ax.config prefixer_warnings; then
                true debug echo "prefixer warnings disabled: $* but do nothing";
            else
                echo -e "\e[33;1m[prefixer/$LINENO/$BASH_SOURCE]warning\e[0;33m:\e[0;1m $1";
                echo -e "\e[30;1mhint: $2 \e[0m";
            fi
        };
    else
        true debug echo "prefixer warning already defined, using cached version";
    fi;
    if [[ -x $CMDNAME ]]; then
        case $PREFIX in 
            !)
                CMDPFX=sudo
            ;;
            @)
                CMDPFX=coproc;
                CMDSUFF="&> /dev/null &"
            ;;
            %)
                CMDPFX="nice ionice"
            ;;
            ^)
                CMDPFX=man
            ;;
            :)
                CMDPFX=thunar
            ;;
            _)
                CMDPFX=pushd
            ;;
            -)
                CMDPFX=popd
            ;;
            +)
                CMDPFX="bash --norc -c"
            ;;
            =)
                CMDPFX=builtin
            ;;
            \?)
                CMDPFX=exec;
                GI=1
            ;;
            \*)
                CMDPFX=bg;
                GI=1
            ;;
            \.)
                CMDPFX=source;
                GI=1
            ;;
            *)
                CMDPFX="";
                prefixer.warning "prefix \"$PREFIX\" unknown - aborting prefixication..." "set option prefixer_warnings=0 in $AX_BASE/config/autoxrc to disable these messages"
            ;;
        esac;
        if ((GI)); then
            prefixer.warning "glob-interference prefix \"$CMDPFX\" used, be mindful of the filenames in $PWD when using a gi-prefix." "use backslash to override normal glob behavior (set prefixer_warnings=0 to turn off these messages)";
        fi;
        if ax.config.has prefixer_notify && ! ax.config prefixer_notify; then
            for ((j=0; j<11; j++))
            do
                echo -e "\e[1;34m$(printf '%40s' ' ')";
            done;
            echo -ne '\e[[10A';
            echo "CMDARGS           ";
            echo "                  ";
            echo " CMDNAME=$CMDNAME";
            echo " ORGCMD=$ORGCMD";
            echo " PREFIX=$PREFIX";
            echo " SUFFIX=$SUFFIX";
            echo " CMDPFX=$CMDPFX";
            echo " CMDSUFF=$CMDSUFF";
            echo "                 ";
            echo -ne '[0m';
        fi;
        if [[ -n $CMDPFX ]]; then
            AX_PX_STATUS="CMDPFX is a-go";
            if [[ $CMDPFX =~ --norc ]]; then
                eval $CMDPFX -- $CMDNAME '"$@"' $CMDSUFF;
            else
                eval $CMDPFX $CMDNAME '"$@"' $CMDSUFF;
            fi;
            return $?;
        else
            AX_PX_STATUS="CMDPFX is no-go";
            :;
        fi;
    fi;
    TMPFILE=$(mktemp);
    exec 3>&1 4>&2;
    exec > $TMPFILE 2>&1;
    cnfh_stub "$ORGCMD" "$@";
    exec 1>&3 2>&4;
    exec 3> /dev/null 4> /dev/null;
    cat $TMPFILE;
    if grep --color=auto -q apt-get $TMPFILE; then
        while true; do
            PKGLINE=`grep -P '^(sudo\s)?apt-get' $TMPFILE`;
            PKGNAME=`echo "$PKGLINE" | grep -Po '(?<=apt-get install\s)\S+'`;
            echo -n "You want to install [1m$PKGNAME[0m? [y]es [n]o e[x]amine <ENTER=[n]o>:";
            TMPRES=$(mktemp);
            unset REPLY;
            until [[ $REPLY =~ [ynx] ]] || [[ -v REPLY && -z $REPLY ]]; do
                unset REPLY;
                ( read -en1 &> $TMPRES );
                REPLY=$(cat $TMPRES);
            done;
            cat $TMPRES;
            if [[ $REPLY == y ]]; then
                unset SUDO;
                if [[ $UID -ne 0 ]]; then
                    SUDO=sudo;
                fi;
                ${SUDO+ $SUDO }apt-get install $PKGNAME;
            else
                if [[ $REPLY == x ]]; then
                    echo -e "\e[1;44m\e[2K$PKGNAME\e[0m";
                    apt-cache show $PKGNAME;
                    echo -e "\e[1;44m\e[2K$PKGNAME\e[0m";
                    continue;
                fi;
            fi;
            break;
        done;
    fi
}
cnfh_stub () 
{ 
    if [ -x /usr/lib/command-not-found ]; then
        /usr/lib/command-not-found -- "$1";
        return $?;
    else
        if [ -x /usr/share/command-not-found/command-not-found ]; then
            /usr/share/command-not-found/command-not-found -- "$1";
            return $?;
        else
            printf "%s: command not found\n" "$1" 1>&2;
            return 127;
        fi;
    fi
}
command_not_found_handle () 
{ 
    cnfh "$@"
}
date () 
{ 
    ?date +%c
}
dequote () 
{ 
    eval printf %s "$1" 2> /dev/null
}
f_def () 
{ 
    single_pass_func "$@";
    return $[ $? | 1 ]
}
f_undef () 
{ 
    single_pass_func "$@";
    return $[ $? ^ 1 ]
}
func () 
{ 
    true;
    case $# in 
        0)
            declare -pF
        ;;
        1)
            __func "$1"
        ;;
        *)
            for x in "$@";
            do
                __func "$x";
            done
        ;;
    esac
}
galias () 
{ 
    ax.checkaliasdir || return 2;
    alias --nolocal "$@"
}
gexport () 
{ 
    ax.checkaliasdir || return 2;
    local EXPCNT=0;
    if [[ $# -gt 0 ]]; then
        for $i in "$@";
        do
            local EXPORTED=0;
            for $j in "${!BASH_ALIASES[@]}";
            do
                if [[ $i == $j ]]; then
                    builtin alias "$j" >> $AX_BASE/"$i";
                    ax.echo "exported $j";
                    EXPORTED=1;
                fi;
            done;
            let EXPCNT+=EXPORTED;
            ((EXPORTED)) || echo "alias not found: $i";
        done;
        ax.echo "$EXPCNT alias(es) exported$(let EXPCNT-$# && echo ,\ $[\ EXPCNT-$#\ ]\ skipped. || echo \.)";
    else
        local n=0;
        echo;
        echo "Aliases on $HOSTNAME for $USER($UID):";
        echo;
        for i in $AX_BASE/*;
        do
            ax.echo "$i[30G$(stat $i --format=%s)";
            let n+=1;
        done;
        echo;
        echo "$n aliases.";
        echo;
    fi
}
gunalias () 
{ 
    ax.checkaliasdir || return 2;
    unalias --nolocal "$@"
}
in_array () 
{ 
    local i;
    for i in "${@:2}";
    do
        [[ $1 = "$i" ]] && return;
    done
}
isfunc () 
{ 
    FUNC_ISFUNC_CMP_MODE=${AX_FUNC_CMPMODE};
    [[ $FUNC_ISFUNC_CMP_MODE =~ ^(and|or)$ ]] || { 
        FUNC_ISFUNC_CMP_MODE=or;
        echo "warn: AX_FUNC_CMPMODE setting is not supported: $AX_FUNC_CMPMODE"
    };
    case $# in 
        0)
            echo "syntax: isfunc [-and|-or] names";
            false
        ;;
        1)
            declare -pF "$1" &> /dev/null
        ;;
        *)
            eval {unset,local}\ EVALSTR\;;
            for z in unset local;
            do
                $z EVALSTR;
            done;
            unset EVALSTR;
            local EVALSTR;
            for x in "$@";
            do
                case $x in 
                    -or)
                        FUNC_ISFUNC_CMP_MODE=or
                    ;;
                    -and)
                        FUNC_ISFUNC_CMP_MODE=and
                    ;;
                    *)
                        isfunc $x;
                        [[ -n $EVALSTR ]] && { 
                            case $FUNC_ISFUNC_CMP_MODE in 
                                or)
                                    EVALSTR+=" | "
                                ;;
                                and)
                                    EVALSTR+=" & "
                                ;;
                            esac
                        };
                        EVALSTR+="$?"
                    ;;
                esac;
            done;
            echo "Evaluate: $EVALSTR";
            eval "(( $EVALSTR )) && R=1 || R=0";
            echo "R = $R"
        ;;
    esac
}
lalias () 
{ 
    ax.checkaliasdir || return 2;
    builtin alias "$@"
}
lunalias () 
{ 
    ax.checkaliasdir || return 2;
    builtin unalias "$@"
}
mvfunc () 
{ 
    eval `declare -pf $1 | sed 's/'$1'/'$2'/g'`
}
promptfactory () 
{ 
    local TEMP=`getopt -o h?f:es:: --long help,setfunc:,editor,show:: -n '$FUNCNAME' -- "$@"`;
    local HELP='
'`cat $BASH_SOURCE | perl -wne 'print if /'"$PROMPTFACTORY_HELP_START"'/ .. /'"$PROMPTFACTORY_HELP_END"'/'`'

';
    local HELP=`eval "echo \"$HELP\""`;
    if [ $? != 0 ]; then
        echo "Terminating..." 1>&2;
        exit 1;
    fi;
    eval set -- "$TEMP";
    while true; do
        case "$1" in 
            -f | --setfunc)
                eval "AX_PROMPT_FUNCTION='\$$2'";
                shift 2
            ;;
            -e | --editor)
                echo "launching editor";
                shift;
                PF_ACTION=runeditor
            ;;
            -s | --show)
                PF_ACTION=show;
                case "$2" in 
                    "")
                        unset PF_ACTION_ARG;
                        shift 2
                    ;;
                    *)
                        PF_ACTION_ARG="$2";
                        shift 2
                    ;;
                esac
            ;;
            --)
                shift;
                break
            ;;
            -h | -\? | --help)
                echo -n "$HELP" | sed -r 's/^.{'$PROMPTFACTORY_HELP_TRIMLEADINGCHARCOUNT'}//g';
                echo -e "\n";
                return 0
            ;;
            *)
                echo "$PROMPTFACTORY_HELP_BAD_OPTION $1";
                exit 1
            ;;
        esac;
    done;
    case $PF_ACTION in 
        runeditor)
            $AX_BASE/lib/promptfactory.pl "$@"
        ;;
        show)
            [[ -n $PF_ACTION_ARG ]] || PF_ACTION_ARG="all";
            case PF_ACTION_ARG in 
                all | prompt)
                    echo "$PS1"
                ;;&
                all | more)
                    echo "$PS2"
                ;;&
                all | select)
                    echo "$PS3"
                ;;
                *)
                    echo "warning: unknown show type: $PF_ACTION_ARG"
                ;;
            esac
        ;;
        "")
            echo "please type $FUNCNAME --help for help";
            return 127
        ;;
        *)
            echo "error: action ${PF_ACTION-was not specified}${PF_ACTION+ is unknown}!"
        ;;
    esac
}
promptfactory_editor () 
{ 
    if ! perl -w -s -I "$AX_BASE/lib" "$AX_BASE/lib/promptfactory.pl" -- "$@"; then
        echo "$PROMPTFACTORY_HELP_BAD_EDITOR $?";
    fi
}
promptfactory_loader () 
{ 
    if [[ $(declare -p PS1) =~ -r ]]; then
        echo "* Bypassing PromptFactory Init (init already happened)";
    else
        declare -gr PS1='$(ax.promptfactory PS1 $?)' PS2='$(ax.promptfactory PS2 $?)';
        declare -g PS3="select: " PS3_CACHE=$PS3;
        echo "* Prompt Factory Feature Enabled, use 'promptfactory' to edit your Prompts";
    fi;
    unset -f $FUNCNAME
}
quote () 
{ 
    local quoted=${1//\'/\'\\\'\'};
    printf "'%s'" "$quoted"
}
quote_readline () 
{ 
    local quoted;
    _quote_readline_by_ref "$1" ret;
    printf %s "$ret"
}
silent () 
{ 
    "$@" &> /dev/null
}
single_pass_func () 
{ 
    for x in "$@";
    do
        if [[ $(compgen -A function | grep -Po '^'"$x"'$') == "$x" ]]; then
            true nop;
        else
            return 1;
        fi;
    done;
    return 0
}
unalias () 
{ 
    if [[ $0 =~ bash ]]; then
        ax.checkaliasdir || return 2;
        local NOLOC=0;
        [[ $1 == '--nolocal' ]] && NOLOC=1;
        if [[ $NOLOC -ne 1 ]]; then
            builtin unalias "$@";
        else
            if [[ $# == 0 ]]; then
                echo "required: alias name";
            fi;
        fi;
        [[ $# -eq 0 ]] && return;
        if [[ -r $AX_BASEe/alias/$1 ]]; then
            rm $AX_BASE/alias/$1;
            ax.echo "Global alias removed";
        else
            ax.echo "Not global so no global file removed.";
        fi;
    else
        builtin unalias "$@";
        return $?;
    fi
}
unfunc () 
{ 
    true;
    case $# in 
        0)
            echo "required: name of func(s) to remove";
            false
        ;;
        1)
            __unfunc "$1"
        ;;
        *)
            for x in "$@";
            do
                __unfunc "$x";
            done
        ;;
    esac
}
