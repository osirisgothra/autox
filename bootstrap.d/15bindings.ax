#!/bin/bash -c false -- "cannot run this file"
# vim: ft=sh:fen:fdm=syntax:fcl=all:fdo=hor:tw=0:sw=2:ts=2

# ax file-based bind configuration (loads FIRST)
echo "looking for a bind configuration included with autox (both in user/system parts)..."
for r in $AX_USERBASE/bind.conf $AX_BASE/bind.conf $HOME/.inputrc; do
    if [[ -r $r ]]; then
        echo "found bind config in $r, which will take precedence over any other location(s), including $HOME/.inputrc"
        declare -gx AX_BINDCONF="$r"
    fi
done
if [[ ! -r $AX_BINDCONF ]]; then
    echo "warning: no bind config is defined!"
    declare -gx AX_BINDCONF="$(mktemp)"
    echo "placing dummy bind for this session in $AX_BINDCONF..."
    echo "please copy this or make your own if you want to have a permanant primary configuration"
    echo "(this of course does not take place of the config done by $BASH_SOURCE after this point!)"
fi
if [[ ! -r $AX_BINDCONF ]]; then
    echo "Panic: something went unreadable: $AX_BINDCONF"
    echo "binding not available, stop!"
    echo "[ press any key to continue (aborting $BASH_SOURCE) ]"
    read -sn1
    return 129
else
    # everything is ok to this point and we have a valid AX_BINDCONF variable
    # so load it
    echo -ne "loading $AX_BINDCONF..."
    if bind -f "$AX_BINDCONF"; then
        echo "ok"
    else
        echo "error? ($?) - check $AX_BINDCONF for errors!"
        echo "[ press any key to continue ]"
        read -sn1
    fi
fi
echo "bind primary loaded, now configuring subsystem-level bindings..."

function _b_edit_loc 		{
	[[ ! -v $EDITOR ]] && EDITOR=vim
	$EDITOR ~/.bashrc
}
function _b_edit_glo {
	[[ ! -v $EDITOR ]] && EDITOR=vim
	if [[ $UID -ne 0 ]]; then
		if sudo -l $EDITOR &> /dev/null; then
			sudo $EDITOR /etc/bash.bashrc
		else
			echo "sudo access denied, read only privs..."
			$EDITOR /etc/bash.bashrc
		fi
	else
		$EDITOR /etc/bash.bashrc
	fi
}
function _b_setupvars() {
	if [[ $UID -lt 1000 ]]; then
		GLOF2="F2"
		LOCF2="Ctrl+F2"
		GLOF2_k="kf2"
		LOCF2_k="kf14"
	else
		GLOF2="Ctrl+F2"
		LOCF2="F2"
		GLOF2_k="kf14"
		LOCF2_k="kf2"
	fi
}

## function _detect_terminal()
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  {
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      function _fok()
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      {
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##          # preserve $? (and global R)
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##          local -i R=$?
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##          case $1 in
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##              y)
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                  #TODO: I will be changing this when the configuration parcel loader 
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                  #      comes into play, change to $AX_CONFIG[no_failterm_msg] instead
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                  #      but since it requires dynamic allocation, keeping it offline right now.
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                  if ax.config.has no_failterm_msg && [[ $(ax.config.get no_failterm_msg) == 1 ]]; then
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                      true debug echo "config ok no_failterm_msg=1, not showing message even though configured"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                  else
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                      if [[ $PREFERRED_TERM ]]; then
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                          echo "*** WARNING, PREFERRED_TERM SET AND IGNORED BECAUSE WE AUTODETECTED OKAY *** (use no_failterm_msg=1 in config to disable warning)"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                      fi
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                  fi
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                  ;;
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##              n)
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                  true debug echo "unsetting _fok (but NOT ok!) :)"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                  ;;
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##              *)
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                  # dont tolerate rogue values
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                  echo "FAILURE: _fok called with a bad value, stop!!!!!"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                  echo "not really, but press ENTER to continue..."
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                  read -sn1
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                  return 1
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##                  ;;
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##          esac
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##          unset -f _fok
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##          return $R
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      }
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      echo -e "\e[1m*\e[0m Detecting Terminal"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      if whatis $AX_TERMINAL |& grep '\bX\b' | grep 'terminal' | grep 'emulator' &> /dev/null; then
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##          echo -e "\e[1m*\e[0m 256color/X-based Terminal (emu=$AX_TERMINAL)"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##          _fok y
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      elif infocmp &>/dev/null; then
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##          echo -e "\e[1m*\e[0m Terminal OK (already set and needs no upgrade)"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##          _fok y
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      else
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##          echo "WARNING: \$TERM not set, and process under PPID not known, forcing manual detection..."
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    echo -n "\e[1m*\e[0m Manual Terminal Detection Forced (automatic failed)"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##          # in this day and age, its pretty easy to guess a user's term
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    # if this is not right for you, please add your own into the config
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      	if ax.config.has custom_terminal; then
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    	local NEWTERM="$(ax.config.get custom_terminal)"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      		case $NEWTERM in
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  			    keep)	echo "Left Untouched ($TERM)";;
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  		    	*) 		echo "Usera-Defined ($NEWTERM)"; TERM="$NEWTERM";;
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    	esac
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      	else
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      	    # fallback to 256-color when in X11, an emulated X environment,
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      	    # unity8+(mir), or, weston(wayland)
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  		    if xprop -root &> /dev/null; then
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    		TERM="xterm-256color"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      		else
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      			case $(tty) in
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  			    	*/*tty*[0-9])
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  		    			if [[ -L /vmlinuz ]]; then
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    					TERM=linux;
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      					else
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  						    TERM=cons25;
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  					    fi
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  				    	;;
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  			    	*/pt*)
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    				if [[ ! -z "$PREFERRED_TERM" ]]; then
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    				    echo "PREFERRED_TERM variable set: honoring its setting no matter what: $PREFERRED_TERM"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    				    export TERM="$PREFERRED_TERM"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    				else
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    				    echo "non-console virtual terminal, with no TERM variable set"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    				    echo "failing back to \"ansi\" because it has the best"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    				    echo "chance of compatibility and is still readable if not."
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    				    echo ""
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    				    echo "hint: set PREFERRED_TERM in your .bashrc if you know"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    				    echo "      what your terminal is, or want to force it on fallback"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    				    echo "      note that this only works for FAILED detections!"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    				    echo ""
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    				    export TERM=ansi
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    				fi
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      					# for safety and maximum compatibility
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  					    ;;
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  				    *)
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  			    		# 80-column, no line len, with
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  		    			# limited support for Bell, Carriage Returns,
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    				# Delete,and/or Backspace
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      					TERM=dumb
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  				    	;;
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  			    esac
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  		    fi
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	    	echo " [detected as $TERM]"
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	        _fok n
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##      	fi
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	fi
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	# notice: do NOT return anywhere in this function except the last line
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	# because it will cause a memory leak from not cleaning up _fok
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  	
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  
## REMOVED [see 05terminal.ax] ## message will be removed next commit ##  }
function _b_reload() {

		GLOF2_B="$(tput $GLOF2_k)"
		LOCF2_B="$(tput $LOCF2_k)"

		# must eval because we can't expand $XXXF2_B inside of '' in just one pass

		eval "bind -x '\"$GLOF2_B\": _b_edit_glo'"
		eval "bind -x '\"$LOCF2_B\": _b_edit_loc'"

		bind -x '"\C-p": _b_perltoggle'
		bind -x '"\C-n": _b_reresource'
		bind -x '"\C-o": _b_commit'
		bind -x '"\C-f": _b_flushme'
		bind -x '"\C-e": _b_poweroff'
		bind -x '"\C-a": _ctrl_a_handler'
		bind -x '"\C-l": clear'
		bind -x '"\C-k": { clear; $AX_BASE/bin/dirs-short; }'
		bind -x '"\C-b": { echo "c=[${BASH_ARGV[@]}]s=[$*]l=[$_]"; }'
		bind -x '"[1;3A": cd ..'
}
function _b_perltoggle()
{
	if [[ $1 == SETUP ]] && [[ ! -v PERLMODEPATH && ! -v PERLLIBPATH ]]; then
		true debug echo "Setting Defaults for Perl Modes (Just Two: AP On/Off)"
		true debug echo "Set your own by creating an array of PERLMODEPATHs and PERLLIBPATHs"
		if ax.config.has perl_mode_paths; then
			eval declare -ga PERLMODEPATH=( `ax.config perl_mode_paths` )
			eval declare -ga PERLMODELIB=( `ax.config perl_mode_libs` )
		fi
		if [[ ${#PERLMODEPATH[@]} -lt 2 ]] || [[ ${#PERLMODELIB[@]} -lt 2 ]]; then
			declare -ga PERLMODEPATH=( "$PATH" "/opt/activeperl/bin:$PATH" )
			declare -ga PERLMODELIB=( "" "/opt/activeperl/lib" )
			PERLTOGGLEMODE="(${#PERLMODEPATH[@]} alternatives configured!)"
		else
			PERLTOGGLEMODE="(unconfigured sample settings mode)"
		fi
		if [[ $1 == SETUP ]]; then
			# force into mode 0 by setting to > max index
			ACTIVEPERL_MODE=${#PERLMODEPATH[@]}
			_b_perltoggle SETUP_MSG
			# print debug message and finish
			#[[ -r ~/.debugmsg ]] && echo "setup complete."
			return
		fi
	elif [[ $1 == SETUP ]]; then
		echo "PERLTOGGLE: already set up"
    	return
	fi
	local -a MODES=( '[32;1mSystem (Perl 5.18.2)[0m' '[35;1mActivePerl+Perl 5.20.1[0m' )
	[[ -v ACTIVEPERL_MODE ]] || declare -gi ACTIVEPERL_MODE
	let ACTIVEPERL_MODE++
	if [[ $ACTIVEPERL_MODE -ge ${#PERLMODEPATH[@]} ]]; then
		ACTIVEPERL_MODE=0
	fi
	if [[ $1 == SETUP_MSG ]]; then
		echo "\e[1m*\e[0m Perl Mode Switcher Created (Starting with ${MODES[$ACTIVEPERL_MODE]})"
	else
		echo "Perl Mode Now: ${MODES[$ACTIVEPERL_MODE]}"
	fi
	export PATH="${PERLMODEPATH[$ACTIVEPERL_MODE]}"
	export PERL5LIB="${PERLMODELIB[$ACTIVEPERL_MODE]}"
	if [[ -z $PERL5LIB ]]; then
		unset PERL5LIB
	fi
}; [[ ! -v ACTIVEPERL_MODE ]] && _b_perltoggle SETUP
function _b_reresource()
{
	echo -ne "Re-Resourcing..."
	echo "setting defaults..."
	set +o nounset
	shopt -s progcomp
	shopt -u nullglob
	unset IFS
	echo -ne "completion..."
	command source /etc/bash_completion
	command source /usr/share/bash-completion/bash_completion
	# for the extreme case of a present 'have' variable
	# this is also done via the usual completion loader (/usr/share/bash-completion/bash_completion)
	# but we don't run that because we do not want it to run
	# ~/.bash_completion which is (to autox) a symbolic
	# link back to autox.

	# TODO: compare execution times (in no less than 1ms)
	# of using the function have() vs. sed-remove
	# ~/.bash_completion from /usr/share/bash-completion/bash_completion
	# if there is more than a ~250ms+ difference, swap them out
	# if the difference is large and machine dependant then create
	# both features and map it into configuration, use the avergage
	# high performer on popular setups as the default setting.

    # TODO: remove TODOs from this file when all tasks are completed

	have_BACKUP=$have
	# connect have to _have (what completers expect)
	have()
	{
		unset -v have
		_have "$@"
	}
	echo -ne "completion loaders..."
	for i in /usr/share/bash-completion/completions/*; do
		echo -ne "[2K[scompletion loaders...$i[u"
		command source "$i"
	done
	echo -ne "completion loaders... bindings"
	bind '"	": complete'
	# remove function and restore
	# have to former state if it had one
	unset -f have
	[[ -n $have_BACKUP ]] && have=$have_BACKUP
	echo -ne "finished."
}
		function _b_commit()
		{
			# TODO: remove in wake of live environment changes, the _b_commit() function and chained keystroke(s)
			echo "*** live environment changes:"
			echo "*** commit no longer is used and this function will soon be removed"
			echo "*** please make needed adjustments so you no longer see this message!"
			# end of TODO scope next line below
		}
		function _b_flushme()
		{
			# for debugging, but also good for scrollback use
			# we dont want to confuse old data with new..
			# this is why I am leaving this as a nondebug setting
			if ax.config.has disable_flush_longlines && [[ $(ax.config disable_flush_longlines) == true ]]; then
				true debug echo "nb: long-line flushout is disabled at this time."
			else
				eval "for i in {0..$((LINES*COLUMNS))}; do echo; done"
			fi
			echo -e "\n\n**** Starting a New Session ****\n"
				exec "$SHELL"
		}
		function _b_poweroff()
		{
			echo "really power down? [y/[n]]"
			if [[ $(read -sn1; echo $REPLY) == y ]]; then
				echo "please pick method (these are supported by your system):"
				for supported in hibernate suspend suspend-hybrid; do
					if pm-supported $supported; then
						others+=( pm-$supported )
					fi
				done
				select method in powerdown ${others[@]}; do
					if [[ $method == powerdown ]]; then
						shutdown -P now
					else
						$method
					fi
				done

			fi
		}


		function _ctrl_a_add() { [[ ! -v BASH_CA_HANDLERS ]] && declare -ga BASH_CA_HANDLERS; BASH_CA_HANDLERS+=( "$@" ); }
	    function _ctrl_a_del()
		{
			case $# in 0) echo "usage: $FUNCNAME [handler|index] ..."; return 1;; esac

			if [[ ! -v BASH_CA_HANDLERS ]]; then
				declare -ga BASH_CA_HANDLERS
			else
				declare -n b=BASH_CA_HANDLERS
				declare -ga NEW_BCH=( )
				declare -i i=0
				declare -i max=${#b[@]}
				# elements removed two ways: $n represents an index, or $n represents the data
				# elements may be data or indexes, and can be interleaved as either
				NEEDSMOD=0
				for ((i=0;i<max;i++)); do
					for j in "$@"; do
						if [[ $j != $i ]] && [[ $j != "${b[i]}" ]]; then
							NEW_BCH+=( "${b[i]}" )
						else
							echo "removed $j (index=$i, data=${b[i]}) from handlers!"
							NEEDSMOD=1
						fi
					done
				done
				case $NEEDSMOD in
				 1) 	BASH_CA_HANDLERS=( "${NEW_BCH[@]}" )	;;
				 0)		echo "Error: none found ($*)" 			;;
				esac
			fi
		}

		function _ctrl_a_handler()
		{
			if [[ -v BASH_CA_HANDLERS ]]; then
				for i in "${BASH_CA_HANDLERS[@]}"; do
					$i "$@"
				done
			else
				echo "No Hook (CTRL+A) Handlers Installed, Install One First"
			fi
		}


	function _b_showhlp_page_text
	 {

		echo "---------------------------------------------------------------"
		echo " Press Ctrl+N To Reload Completions/Aliases Any Time"
		echo " Press Ctrl+O To Output Aliases/Completions to Cache"
		echo " Press Ctrl+D To Logout"
		echo " Press Ctrl+F To Flush Session Changes"
		echo " Press Ctrl+E To Exit System and Power Down"
		echo " Press Ctrl+L To Clear The Screen"
		echo " Press Ctrl+K For A Compact Directory Listing"
		echo " Press Alt+Up To Go Up One Directory Branch"
		echo " Press Ctrl+P To Change Perl Mode"
		echo " Press F1 To Show This Page Again and Reload Bindings"
		echo "---------------------------------------------------------------"
		echo "Press $GLOF2 To Edit Global Bash Startup (/etc/bash.bashrc)"
		echo "Press $LOCF2 To Edit Local Bash Startup (~/bash.bashrc)"
		echo "---------------------------------------------------------------"

	}

	function _b_showkeyhelp_page_
	{
		echo -ne "[0;44m"
		bind -p | grep -P 'self-insert|backward-ch|lowercase-ver|not bound|[a-z]-insert' -v | sed -r 's/\\\C/Ctrl/g;s/\\e/Esc-/g' | tr  '"' ' '                 | sed -r 's/(\S)(Ctrl|Esc)/\1,\2/g' | sed -r 's/(Ctrl|Esc)(-)(\s|,)/\1\3/g'      | awk ' { printf "[1m%-20s[0;44m\t%s\n",$1,$3}; ' | column -c $COLUMNS | sed -r 's/-/[1;30m-[0;44m/g'

	}
	function _b_showhlp_page
	{
		if [[ $1 == SETUP ]]; then
			_detect_terminal
			_b_setupvars
			_b_reload
			_b_reload_f1
		fi
		echo "\e[1m*\e[0m Keyboard Bindings and Display Help (F1=Help F2=Readline Bindings)"


	}
	#RELOAD_BINDINGS_DISCLUDE

	function _b_reload_f1() {
		# do not put in reload_bindings because
		# it will cause errors if rebound during
		# it's processing itself:
		bind -x '"'$(tput kf1)'": _b_showhlp_page;_b_showhlp_page_text'
		bind -x '"'$(tput kf2)'": _b_showkeyhelp_page_'
	}


stty sane

#reload_bindings# no longer used
_b_showhlp_page SETUP

# Agressive Minimal Function -> LongOpt Function
# use longopt insetad of minimal for unknown completions
# this is done by default in autox but we do it here too
# as a countermeasure of other offending programs. You
# can disable it by adding the line 'no_aggressive_minimal=anyvalue'
# to your ../etc/autoxrc
if ! ax.config.has no_aggressive_minimal; then
	if ! ax.isreadonlyfunc _minimal; then
		function _minimal() { _longopt "$@"; }
	fi
fi

# standard ax parts, followed by the stubs (put extra code in those)
declare -Ag AX_DESCRIPTION[$BASH_SOURCE]="$(head $BASH_SOURCE | grep -Po '(?<=Description: ).*')"
function _compbind.ax_POSTLOAD() {	ax.echo "$AX_DESCRIPTION{$(basename $BASH_SOURCE)}: $FUNCNAME.$LINENO: loaded"; eval "${FUNCNAME}_stub \"\$@\""; }
function _compbind.ax_PRELOAD()  {	ax.echo "$AX_DESCRIPTION{$(basename $BASH_SOURCE)}: $FUNCNAME.$LINENO: loading";eval "${FUNCNAME}_stub \"\$@\""; }
function _compbind.ax_REMOVE()	 {	ax.echo "$AX_DESCRIPTION{$(basename $BASH_SOURCE)}: $FUNCNAME.$LINENO: removed";eval "${FUNCNAME}_stub \"\$@\""; }
# stubs (core)
_compbind.ax_POSTLOAD_stub() { : ; }
_compbind.ax_PRELOAD_stub() { : ; }
_compbind.ax_REMOVE_stub() { : ; }



