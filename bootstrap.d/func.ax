#!/bin/bash

unset AX_FUNCS
declare -gA AX_FUNCS
declare -g AX_FUNC_CMPMODE=or
declare -gA AX_FUNC_CMPMODES=( [and]="&" [or]="|" )
source "$AX_BASE/bootstrap.d/axmacros.ax"


isfunc_usage()
{
    case $1 in
        short|long)
            __isfunc_usage "$@";;
        *)
            echo "must be called with either 'short' or 'long'!"
            return 1;;
    esac
    return $?
}

############# __isfunc_usage [short|long]

__isfunc_usage()
{
    case "$1" in
        short)
            echo "usage: isfunc [-print -any] name [[-any -print|-unany -unprint] name ...]"; return 2;;
        long)
            __isfunc_usage short
            cat <<-EOF

            returns whether a function or functions are valid 'func' types

            switches

            -print      turn on printing for following observations
            -any        turn on anymode, which returns TRUE (0) if any match given
            -unany      turns anymode back off for following observations
            -unprint    turns printing back off for following observations
            -help       this help message

            parameters

            name        name of 'func' to be checked. this item must exist in
                        AX_FUNCS global array hash. if it is not, then the item
                        is assumed a normal function and fails.

            for more info on the autox 'func' feature, please read the
            documentation in AX_BASE/docs folder, or visit the repository
            at http://osirisgothra.github.io/autox

            examples

                isfunc  goodfunc -any anothergood anotherbad
                (returns true because -any matches)
                isfunc -any goodfunc -unany anothergood anotherbad
                (returns false because any was turned back off)
                isfunc goodfunc -any badfunc -unany goodfunc -any badfunc2 goodfunc2
                (returns true, badfuncs were inside -any blocks)
                isfunc somefunc -print otherfunc
                (returns info about otherfunc and final results)
                isfunc -print somefunc -unprint otherfunc
                (returns info about somefunc, but not otherfunc nor the totals)
                isfunc somefunc anotherfunc -print
                (returns printing of final results ONLY)

          defaults

            the defaults are '-unany' and '-unprint' at this time

          contact

            you can contact the developer at osirisgothra@hotmail.com

EOF
            ;;
       *) echo "fatal: bad help usage command, need short or long!"
        ;;
 esac
}

################## (stub) __isfunc [isfunc arglist] !TODO! stub not currently in use !TODO!

function __isfunc()
{
    isfunc "$@"
}

################## isfunc [[query name/item] [...]]

function isfunc()
{
    # cols = columns = columns on screen or fallback to linux console default width of 80
    local COLS=${COLUMNS-80}
    local HALF=$(( COLS / 2 ))
    local ANYMODE=0
    local PRINTMODE=0
    local b=""
    local e="exclusive"

    ### TODO: following is THE rewrite, please complete it
    # multi-argument is batch arguments
    case $# in
        0)  __isfunc_usage short
            return
            ;;
        1)  if [[ $1 == --help ]]; then
                __isfunc_usage long
            else
                # single argument is test argument
                if [[ -v AX_FUNCS[$1] ]]; then
                    return 0
                else
                    return 1
                fi
            fi
            ;;
        *)  # more than one argument? batch time!
            for b in "$@"; do
                if [[ $b == "-unany" ]]; then
                    if [[ $ANYMODE -eq 1 ]]; then
                        e='mixed'
                    fi
                    ANYMODE=0
                    continue
                elif [[ $b == "-unprint" ]]; then
                    PRINTMODE=0
                    continue
                elif [[ $b == "-any" ]]; then
                    ANYMODE=1
                    continue
                elif [[ $b == "-print" ]]; then
                    PRINTMODE=1
                    continue
                fi
                if ! isfunc $b; then
                    [[ $PRINTMODE -eq 1 ]] && echo -e "$b\e[${HALF}Gfalse"
                    if [[ $ANYMODE -eq 1 ]]; then
                        continue
                    else
                        [[ $PRINTMODE -eq 1 ]] && echo "at least one non-function in sudden-death mode (false)"
                        return 1
                    fi
                else
                    [[ $PRINTMODE -eq 1 ]] && echo -e "$b\e[${HALF}Gtrue"
                    FOUNDONE=1
                fi
            done
            if [[ $ANYMODE -eq 1 ]] && [[ $FOUNDONE -eq 1 ]]; then
                [[ $PRINTMODE -eq 1 ]] && echo "found at least one function in anymode (true)"
                return 0
            elif [[ $ANYMODE -eq 1 ]]; then
                [[ $PRINTMODE -eq 1 ]] && echo "found NO functions in anymode (false)"
                return 1
            else
                [[ $PRINTMODE -eq 1 ]] && echo "found all functions in $e mode (true)"
                return 0
            fi
            ;;
    esac
    ### TODO: end of THE rewrite

    ### TODO: following is in rewrite, please depreciate it
    ### WARN: no longer using this block of script delete when finished with it
	FUNC_ISFUNC_CMP_MODE=${AX_FUNC_CMPMODE}
	[[ $FUNC_ISFUNC_CMP_MODE =~ ^(and|or)$ ]] || {
		FUNC_ISFUNC_CMP_MODE=or
		echo "warn: AX_FUNC_CMPMODE setting is not supported: $AX_FUNC_CMPMODE"
	}
	case $# in
		0) 	echo "syntax: isfunc [-and|-or] names"; false;;
		1) 	declare -pF "$1" &> /dev/null;;
		*)  eval {unset,local}\ EVALSTR\;
			for z in unset local; do $z EVALSTR; done
			unset EVALSTR;local EVALSTR
			for x; do
				case $x in
					-or)	FUNC_ISFUNC_CMP_MODE=or;;
					-and)	FUNC_ISFUNC_CMP_MODE=and;;
					*)	isfunc $x
						[[ $EVALSTR ]] && {
							case $FUNC_ISFUNC_CMP_MODE in
								or)	EVALSTR+=" | ";;
								and) EVALSTR+=" & ";;
							esac
						}
						EVALSTR+="$?"
				esac
			done
			echo "Evaluate: $EVALSTR"
			eval "(( $EVALSTR )) && R=1 || R=0"
			echo "R = $R"
			;;
	esac
	# WARN: end of scriptblock marked for deletion
}

########### func [[funcname[=[{]| ]codeblock[}]] [...]|]

func()
{
	true
	case $# in
		0)	declare -pF;;
		1)	__func "$1";;
		*)	for x; do __func "$x"; done;;
	esac
}

######### unfunc [[func name] [...]|]

unfunc()
{
	true
	case $# in
		0) echo "required: name of func(s) to remove"; false;;
		1) __unfunc "$1";;
		*) for x; do __unfunc "$x"; done;;
	esac
}

######## (stub) __unfunc {func name}

__unfunc()
{
    local FORCE=0
    if [[ $1 == +force ]]; then
        FORCE=1
        shift
    fi
	if [[ -z ${AX_FUNCS[$1]} ]] && [[ $FORCE -ne 1 ]]; then
		if isfunc $1; then
			echo "$1 is a function, not a func!"
			echo "hint: use unset -f to delete functions."
		else
			echo "$1: unknown func name"
		fi
		false
	else
		if rm "${AX_FUNCS[$1]}" && [[ ! -f ${AX_FUNCS[$1]} ]]; then
			unset -f $1
			unset AX_FUNCS[$1]
			echo "func $1 deleted"
			true
		elif [[ ! -f ${AX_FUNCS[$1]} ]]; then
			echo "warning: func's link (persistent storage) is missing, cannot remove persistent version, if it has one, check your permissions!"
			unset -f $1
			unset AX_FUNCS[$1]
			echo "func $1 delted (locally only)"
			true
		else	
		    if [[ $FORCE -eq 1 ]]; then
		        # force/semiquiet with * indicating removal error
		        echo "func $1 deleted*"
		    else
			    echo "failed to delete $1, check your permissions of ${AX_FUNCS[$1]} and try again"
			    echo "$1 will not be removed from memory unless you are allowed to delete the file."
			    echo "hint: You may delete the file yourself, and then re-run this command to force a delete."
			    false
			fi
		fi
	fi

}
__func()
{
	case $1 in
		*=*)	source /dev/stdin <<EOF
				function ${1%%=*}()
				{
					$(echo ${1#*=})
				}
EOF
				declare -pf ${1%%=*} > $AX_BASE/func/${1%%=*}.af
				;;
		*)		if [[ "${AX_FUNCS[$1]}" ]]; then
					printf "func $1='%s'" "$(declare -pf "$1" | head -n-1 | tail -n+3)"
				else
					echo "Not found and/or tagged as func ($1)"
				fi
				;;
	esac


}
__func_defer_load()
{
    true debug echo "$FUNCNAME: arguments=${@} ($# argument[s] total)"
	declare -gA AX_FUNCS
	declare -ga ORIGARGS=( "$@" )
	true debug echo "$FUNCNAME: caller=$(caller)"
	true debug echo "$FUNCNAME: sources=${BASH_SOURCE[@]} (${#BASH_SOURCE[@]} source(s) total)"
	true debug echo "$FUNCNAME: detail follows..."
	true debug echo "AX_FUNCS CONTENT: DATA=[$(declare -p AX_FUNCS)]"
	if [[ ${1: -3} != '.af' ]]; then
	    true debug echo ".af extension was not provided in first argument, adding it now (original = $1)" 
	    if [[ $# -gt 1 ]]; then
		    set "${1}.af" "${2: -1}"
		    true debug echo "$# > 1; modified arguments: $@ ($# total)"
		elif [[ $# -lt 1 ]]; then
		    echo "ERROR: not enough arguments, need at least a function name!"
		    true debug echo "exiting with 127 out of $FUNCNAME"
		    return 127
		else
		    true debug echo "setting cmdline to ${1}.af alone."
		    set "${1}.af"
		fi
	fi
	if [[ $1 =~ "/" ]]; then
		echo "please do not include directories with the func, it's location is controlled by the AX_BASE variable."
		true debug echo "returning early due to bad name with / in it ($1)?"
		false
		return
	fi
	fname="$AX_BASE/func/$1"
	ftemp="$(mktemp)"
	true debug echo "vars set: fname=$fname  ftemp=$ftemp"
	true debug echo "debugging next few lines ------------"
	#true debug set -x
	cat "$fname" |  perl -wne 'print unless /METADATA_START/ .. /METADATA_END/' > "$ftemp"  && true debug echo "parsed from $fname, without any apparent error, on to the executioner..."
	source "$ftemp" && true debug echo "returned from source $ftemp, no error values reported!"
	rm "$ftemp" && true debug echo "removed $ftemp from $fname okay"
	true debug echo "FNAME=$fname"
	truefname="$(basename ${fname%%.af})"
	AX_FUNCS[$truefname]="$fname"
	true debug echo "truefname=${truefname}"
	# note: it is the caller's responsibility to reset/unset these BEFORE calling the
	# function that might be deferred!!
	declare -gi AX_DEFER_LOAD_RETURN=$?
	declare -gi AX_LAST_CALL_DEFERRED=1
	declare -ga AX_DEFER_PIPESTATUS=( "${PIPESTATUS[@]}" )
	# green light, call with remaining arguments (and strip the .af from the first argument)
	local CALLNAME="${1%.af}"
    true debug echo "about to: \"$CALLNAME\" ARGS=[$@] ARGC=$#"
    # restore original arguments
    set -- "${ORIGARGS[@]}"
    # use callname and shift off first arg
    shift
	"$CALLNAME" "$@"
	return $?
}

__func_loader()
{
	local NONULLGLOB=0
	shopt -q nullglob || NONULLGLOB=1
	shopt -s nullglob
	declare -a fnames=( $AX_BASE/func/*.af )
	local -i tot=${#fnames[@]}
	local -i cur=0
	local -i prc=0
	echo -ne " \e[s\e[0K\e[u"
		if [[ ! -v AX_IGNORED_FUNCS ]]; then
		    declare -Agx AX_IGNORED_FUNCS=( [__placeholder__]="1" )
		    IFS=$'\n'
		    # read config file, but dont read empty lines and comment lines (that start with #)
		    # also it strips spaces while doing this..  .
		    for x in $(cat $AX_BASE/data/ignoreduplicates.dat | grep -vP '^\s*(#|$)'); do
		        AX_IGNORED_FUNCS[$x]=1
		    done
		fi
	local ftemp="$(mktemp)"
	for fname in "${fnames[@]}"; do
		[[ $tot -eq 0 ]] && break
		
		
					
	    let cur++
	    prc=$(( ( cur*100) / tot ))
		true debug echo "PERC=$prc CUR=$cur TOT=$tot"
		
		local FNAME=$(basename $fname | sed 's/\.af$//g' )
		echo -ne "[u${prc}% $FNAME \e[1;30m(\e[0m$(printf '\e[1m%3d\e[11m of \e[1m%3d\e[11m' ${cur} ${tot})\e[1;30m)\e[0m\e[0K\e[u\e[s "
		# TODO: assign this in autox, and load from /$AX?BASE_data/ignoreduplicates.dat #

        	if [[ ${#BASH_ALIASES[$FNAME]} -gt 0 ]]; then
			if [[ ${AX_IGNORED_FUNCS[$FNAME]} == 1 ]]; then
                		echo "assert: ignoring $FNAME because its dual use is intended!"
        		else
	        	        echo "warning: $FNAME is a func which takes precedence over aliases, the alias form will be removed to avoid conflicts."
	        	        echo "(hint: new item on purpose?? great! just add $FNAME to $AX_BASE/data/ignoreduplicates.dat to avoid this message!)"
                		builtin unalias $FNAME
        		fi
		fi
		tfname="$(basename ${fname%%.af})"
#		echo -e "\nfunction $tfname\n{\n\t__func_defer_load $tfname \"\$@\";\n} " >> "$ftemp"
		echo -e "\nfunction $tfname\n{\n\t__func_defer_load \$FUNCNAME \"\$@\";\n} " >> "$ftemp"
#		cat "$fname" |  perl -wne 'print unless /METADATA_START/ .. /METADATA_END/' > "$ftemp"  && true debug echo "parsed from $fname, without any apparent error, on to the executioner..."
#		source "$ftemp" && true debug echo "returned from source $ftemp, no error values reported!"
#		true debug echo "FNAME=$FNAME = $fname"
		AX_FUNCS[$FNAME]="$fname"
	done

	source "$ftemp"
	rm "$ftemp" && true debug echo "removed $ftemp from $fname okay"

	echo "[1m$tot [30;1m'[0mfuncs[30;1m'[0m loaded[30;1m![0m[K"

	[[ $NONULLGLOB -eq 1 ]] && shopt -u nullglob

}

if ! ax.config.has ax.func.disable_all_flag; then
    SECONDS=0
    echo -ne "\e[0G\e[0;36;1m⁜ \e[0;1mF\e[0mu\e[30;1mn\e[1;30m\e[0;34m\e[1mct-lias L\e[0;34mo\e[1;30ma\e[0md\e[1me\e[0;36mr\e[0m, \e[s"
    __func_loader "$@"
    {
    case $SECONDS in
        [0-1]) tput setaf 2; tput bold;;
        [2-3]) tput setaf 3; tput bold;;
            *) tput setaf 1; tput bold;;
    esac
    } | tr -d '\n'
    echo -ne "\e[u Loaded in $SECONDS second(s)\e[0K\e[0m\n"
else
    echo -e "\e[1;30m$BASH_SOURCE : $LINENO : ax.func.disable_all_flag is defined, funcs will not be available!!"
    echo -e "\e[0m... in etc/autoxrc ..."
fi

