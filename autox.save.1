#!/usr/bin/python3

""" " &> /dev/null
    # ============ BEGIN BASH <-> PYTHON3 BRIDGE SCRIPT  ==============================================================

    # BASH BOOTSTRAP CODE, PLEASE DO NOT MODIFY
    # IT IS TO STOP CLASSIC AUTOX EXECUTION AND BOOTSTRAP the python based interpreter
    # VIA THE SOURCE OR DOT COMMANDS (source, .)

    # * SETUP THE ENVIRONMENT
    #       export the return cookie so that the python3 side can see it
    #       this is done because file-based would run the risk of duplicate or sync errors
    #       and completely avoids the PIDFILE/COMPLEX_FILE_NAME_HOST_USER_TTY_ETC_ETC information, kiss
    export RETURN_COOKIE=$(mktemp)
    "$BASH_SOURCE" "_selfinvoke_UUID_728b66b7-1f21-4f2f-bf33-867eb2659726" "setup_autox_environment"

    # * EXECUTE the return cookie
    #       required, or exits with $? = 126 [cookie-dataless] error
    [[ -s $RETURN_COOKIE ]] && source $RETURN_COOKIE || { echo "fatal: return cookie dataless ($RETURN_COOKIE), aborting startup"; return 126; exit 126; }
    # * ENTER MAIN EXECUTION LOOP
    #       this allows autox remain bash-based
    #       while we take advantage of python3 features
    while true; do
        "$BASH_SOURCE" "_selfinvoke_UUID_" "728b66b7-1f21-4f2f-bf33-867eb2659726" "get_ax_client_frame"
        declare -i AX_RCVAL=0
        if [[ -s $RETURN_COOKIE ]]; then
            # the cookie itself may choose to terminate the script
             if ! source $RETURN_COOKIE; then
                AX_RCVAL=$?
                # if this happens the cookie should be deleted now
                rm -f $RETURN_COOKIE
                break
             fi
        else
            # cookie removed, this is done to signal the exit
            break
        fi
    done

    # * PERFORM CLEANUP
    #       cleans anything up that was nonvolitiley created during setup_autox_environment
    "$BASH_SOURCE" "_selfinvoke_UUID_" "728b66b7-1f21-4f2f-bf33-867eb2659726" "cleanup_autox_environment"

    # * EXIT
    #       returns control to the operating system, or, terminates the shell
    #   TODO: do not exit the shell during devel phases until further notice
    #
    # exit $AX_RCVAL
    return $AX_RCVAL

    # ================= END OF BASH <=> PYTHON BRIDGE SCRIPT =======================
    " &> /dev/null

    /begin:python3_module_description/

    autox [aka autox-rewrite]
    autox.startup declaration(s)
    AUTOmated shell eXtensions library
    an "omnimatic" bourne shell extension and a hands-free persistent environment

    Copyright (C) 2003-2016 Paradisim Enterprises, LLC

    (Please see the end of this text for revision history)

    Written by Gabriel T. Sharp <osirisgothra@hotmail.com>
    Latest versions of this and all other projects can be
    obtained by visiting <https://github.com/osirisgothra>

    seasonal mirrors (subject to availability and uptime):

    home-run servers:   <http://paradisim.twilightparadox.com>
    corporate hosted:   <http://paradisim.tk>

    support website(s)

    autox homepage:     <http://osirisgothra.github.io/autox>
    development repo:   <http://github.com/osirisgothra/autox>
    secondary url       <http://osirisgothra.github.com/autox>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

    REVISION HISTORY

    * Tue 19 Apr 2016 01:34:02 PM EDT    osirisgothra on larnica initially created this file
                                         with the original name, "autox-rewrite"
    * Please see HISTORY, NEWS, and README for further revision history will not be listed!

    /end:python_module_description/
"""

import os
import sys
import lib.autox
import pathlib

### Function    - main()
### Arguments   - <none>
### Description - main entry point for autox requests
def main():
   coreuuid = "728b66b7-1f21-4f2f-bf33-867eb2659726"
   ### ensure exact number of arguments and the existence of RETURN_COOKIE
   if len(sys.argv) != 3:
      print("error: expected exactly three arguments [autox [reqhdr] [uuid] [request]",file=sys.stderr)
      return 125
   if os.environ.get("RETURN_COOKIE") is None:
      print("error: the RETURN_COOKIE varible does not indicate the return cookie, this is required!",file=sys.stderr)
      return 126


   # get the return cookie path and make sure it's valid
   # it MUST exist already and be zero-length!


   cookie_path = os.environ.get("RETURN_COOKIE")
   if len(cookie_path) != 0 and pathlib.Path(cookie_path).exists():
      print("cookie path set to {c}".format(c=cookie_path))
   else:
      print("error: cookie path {c} is NOT valid, returning with error before executing the request!".format(c=cookie_path),file=sys.stderr)
      return 127

   #
   # check the length and accessibility of the return cookie
   # dont open in write mode to avoid any trunc-ing of data that could be
   # (quite rarely) a file the user wants to keep (?)
   # a non-zero length cookie file means one of two things:
   #    autox did not process and trunc the cookie
   #    autox did not create this cookie, and it is some other file (extreme rare case)
   # either way, this should not happen so warn the user to delete this file themselves
   # or to restart, in which case a new cookie file will be created by the bash bridge
   # script.
   #

   cookie_file = open(cookie_path)
   cookie_file.seek(0)
   if len(cookie_file.read()) > 0:
      print("fatal: cookie_file ({c}) passed to us with contents, it should be emptied out before being passed back, this is indicative of a timeout or signaled error, stop!".format(c=cookie_path),file=sys.stderr)
      return 128

   # now we know:
   # 1) the RETURN_COOKIE is set
   # 2) the filename exists
   # 3) it is zero-length indicative of "all green" status
   # 4) cookie_file is now our handle we can pass to the core to execute the request
   # 5) the proper number of arguments were given by the user, and the user can read the cookie file

   # execute the request (second argument)
   # cookie_file will be closed when it goes out of scope everywhere

   if axcore.execute_request(sys.argv[2], cookie_file):
   	print("request {r} returned okay! REMOVEME_MSG".format(r=sys.argv[2]))
   	return 0
   else:
   	print("request {r} failed: {a} in {c}".format(r=request,a=axcore,c=cookie_file),file=sys.stderr)
   	return 129

   # module ends

# begin main module entry point
print("entering module autox with arguments: \n{args}".format(args=sys.argv))
print("totaling {n} argument(s)".format(n=len(sys.argv)))
returnValue = main()
print("returning with value {v}".format(v=returnValue))
exit(returnValue)

# file corruption protection
# corrupt disk, file, memory would be the only reason to ever get here:

print("fatal: corruption protection detect, pausing and exiting with error")
print("PLEASE CHECK YOUR FILES FOR CONSISTENCY (AND YOUR HARD DISK!)")
input(":TRYING TO WAIT FOR KEYBOARD INPUT TO PROTECT SYSTEM, PRESS ENTER TO PROCEED OR CTRL+C TO ABORT WITH ERROR (RECOMMENDED!):")


